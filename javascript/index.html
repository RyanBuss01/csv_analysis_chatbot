<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BankersGPS Analytics Chatbot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }

        .chat-container {
            width: 90%;
            max-width: 900px;
            height: 95vh;
            max-height: 95vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            position: relative;
        }

        .analysis-selector {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .analysis-label {
            font-size: 12px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .analysis-dropdown {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
            min-width: 200px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23667eea" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px;
            padding-right: 35px;
        }

        

        .refresh-button {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-50%) rotate(180deg);
        }

        .file-upload-section {
            background: #f8f9fa;
            padding: 5px 20px;
            border-bottom: 1px solid #e1e5e9;
        }

        .file-uploads-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .file-upload-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-type-label {
            font-size: 12px;
            font-weight: 600;
            color: #5a6c7d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .current-file {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            padding: 8px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            min-height: 60px;
        }

        .current-file:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .file-title-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .file-icon {
            font-size: 24px;
            opacity: 0.8;
        }

        .file-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .file-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            line-height: 1.2;
        }

        .file-status {
            font-size: 11px;
            color: #5a6c7d;
            opacity: 0.8;
        }

        .change-file-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .change-file-btn {
            background: transparent;
            color: #667eea;
            border: 1px solid #667eea;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .change-file-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.2);
        }

        .remove-file-btn {
            background: transparent;
            color: #e74c3c;
            border: 1px solid #e74c3c;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-file-btn:hover {
            background: #e74c3c;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.2);
        }

        .no-file-state {
            opacity: 0.6;
            border-style: dashed;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .analyze-center {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            background: #f8f9fa;
        }

        .analyze-center.hidden {
            display: none;
        }

        .analyze-table-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .analyze-table-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .chat-interface {
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            min-height: 0;
        }

        .chat-interface.active {
            display: flex;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f8f9fa;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.bot {
            justify-content: flex-start;
        }

        .message-content {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.6;
            word-wrap: break-word;
            font-size: 14px;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message.bot .message-content {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-bottom-left-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* IMPROVED MARKDOWN FORMATTING */
        .message-content h1, .message-content h2, .message-content h3 {
            margin: 12px 0 8px 0;
            color: #2c3e50;
            line-height: 1.4;
        }

        .message-content h1 { 
            font-size: 18px; 
            margin-top: 0;
        }
        
        .message-content h2 { 
            font-size: 16px; 
            margin-top: 16px;
        }
        
        .message-content h3 { 
            font-size: 14px; 
            margin-top: 14px;
        }

        /* IMPROVED PARAGRAPH SPACING */
        .message-content p {
            margin: 12px 0;
            line-height: 1.6;
        }

        /* First paragraph after headers should have less top margin */
        .message-content h1 + p,
        .message-content h2 + p,
        .message-content h3 + p {
            margin-top: 8px;
        }

        /* IMPROVED BULLET POINT FORMATTING */
        .message-content ul, .message-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .message-content li {
            margin: 8px 0;
            line-height: 1.5;
            padding-left: 4px;
        }

        .message-content li strong {
            font-weight: 600;
            color: #2c3e50;
        }

        .message-content ul ul {
            margin: 8px 0 8px 0;
            padding-left: 32px;
        }

        .message-content ul ul li {
            margin: 4px 0;
            font-weight: normal;
        }

        .message-content li p {
            margin: 4px 0;
        }

        .message-content > p {
            padding-left: 0;
            margin-left: 0;
        }

        .message-content em {
            font-style: italic;
            color: #5a6c7d;
        }

        .message-content code {
            background: #f1f1f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .message-content blockquote {
            margin: 16px 0;
            padding: 8px 16px;
            border-left: 4px solid #667eea;
            background: #f8f9fa;
            font-style: italic;
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            background: white;
            border-radius: 18px;
            border-bottom-left-radius: 5px;
            border: 1px solid #e1e5e9;
            max-width: 80px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #999;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e1e5e9;
        }

        .input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            outline: none;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }

        .send-button:hover {
            transform: scale(1.05);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .success-message {
            background: #2ed573;
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .close-modal:hover {
            color: #333;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .data-table th,
        .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .data-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .pdf-preview {
            width: 100%;
            height: 500px;
            border: none;
            border-radius: 8px;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #666;
        }

        .json-view {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
        }

        .chat-messages::-webkit-scrollbar,
        .modal-content::-webkit-scrollbar,
        .json-view::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .modal-content::-webkit-scrollbar-track,
        .json-view::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .modal-content::-webkit-scrollbar-thumb,
        .json-view::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .modal-content::-webkit-scrollbar-thumb:hover,
        .json-view::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        @media (max-width: 768px) {
            .file-uploads-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .analysis-selector {
                left: 10px;
                flex-direction: column;
                gap: 4px;
            }
            
            .analysis-dropdown {
                min-width: 160px;
                font-size: 10px;
                padding: 6px 12px;
            }
            
            .current-file {
                padding: 8px 16px;
            }
            
            .file-title {
                font-size: 12px;
            }
            
            .change-file-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            .analyze-table-btn {
                padding: 16px 32px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="analysis-selector">
                <div class="analysis-label">Analysis Type</div>
                <select class="analysis-dropdown" id="analysisDropdown">
                    <option value="rate-risk">Rate Risk Management</option>
                    <option value="net-interest">Net Interest Margin</option>
                    <option value="forecast-kri">Forecast KRI</option>
                    <option value="competitive-kri">Competitive KRI</option>
                    <option value="rate-risk-minimal">RRM (minimal)</option>
                    <option value="net-interest-minimal">NIM (minimal)</option>
                    <option value="rate-risk-minimal-docs">RRM (minimal + docs)</option>
                    <option value="net-interest-minimal-docs">NIM (minimal + docs)</option>
                    
                </select>
            </div>
            <button class="refresh-button" id="refreshButton" title="Reset Page">🔄</button>
        </div>
        
        <div class="file-upload-section">
            <div class="file-uploads-container">
                <!-- CSV Upload Section -->
                <div class="file-upload-wrapper">
                    <div class="file-type-label">CSV Data File</div>
                    <div class="current-file" id="currentCsvFile">
                        <div class="file-title-section">
                            <div class="file-icon">📊</div>
                            <div class="file-details">
                                <h4 class="file-title" id="csvFileName">sample_rate_shock.csv</h4>
                                <div class="file-status" id="csvStatus">Active</div>
                            </div>
                        </div>
                        
                        <div class="change-file-wrapper">
                            <div class="file-input-wrapper">
                                <input type="file" id="csvFileInput" class="file-input" accept=".csv,.xlsx,.json">
                                <label for="csvFileInput" class="change-file-btn">
                                    <span>📄</span>
                                    Change
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PDF Upload Section -->
                <div class="file-upload-wrapper">
                    <div class="file-type-label">PDF Source Report (Optional)</div>
                    <div class="current-file" id="currentPdfFile">
                        <div class="file-title-section">
                            <div class="file-icon">📄</div>
                            <div class="file-details">
                                <h4 class="file-title" id="pdfFileName">sample_risk_report.pdf</h4>
                                <div class="file-status" id="pdfStatus">Active</div>
                            </div>
                        </div>
                        
                        <div class="change-file-wrapper">
                            <div class="file-input-wrapper">
                                <input type="file" id="pdfFileInput" class="file-input" accept=".pdf">
                                <label for="pdfFileInput" class="change-file-btn">
                                    <span>📄</span>
                                    Change
                                </label>
                            </div>
                            <button class="remove-file-btn" id="removePdfBtn" title="Remove PDF">✕</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="analyze-center" id="analyzeCenter">
                <button class="analyze-table-btn" id="analyzeTableBtn">
                    <span>🔍</span>
                    Analyze Data
                </button>
            </div>
            
            <div class="chat-interface" id="chatInterface">
                <div class="chat-messages" id="chatMessages"></div>
                
                <div class="chat-input">
                    <div class="input-container">
                        <input 
                            type="text" 
                            class="message-input" 
                            id="messageInput" 
                            placeholder="Ask about your data or BankersGPS documentation..."
                            maxlength="1000"
                        >
                        <button class="send-button" id="sendButton">
                            ➤
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Data Preview</h3>
                <button class="close-modal" id="closeModal">&times;</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const csvFileInput = document.getElementById('csvFileInput');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const currentCsvFile = document.getElementById('currentCsvFile');
        const currentPdfFile = document.getElementById('currentPdfFile');
        const csvFileName = document.getElementById('csvFileName');
        const pdfFileName = document.getElementById('pdfFileName');
        const csvStatus = document.getElementById('csvStatus');
        const pdfStatus = document.getElementById('pdfStatus');
        const removePdfBtn = document.getElementById('removePdfBtn');
        const analyzeCenter = document.getElementById('analyzeCenter');
        const chatInterface = document.getElementById('chatInterface');
        const analyzeTableBtn = document.getElementById('analyzeTableBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const closeModal = document.getElementById('closeModal');
        const refreshButton = document.getElementById('refreshButton');
        const analysisDropdown = document.getElementById('analysisDropdown');

        let currentCsvData = null;
        let currentPdfData = null;
        let currentDataType = 'csv';
        let activeAnalysis = 'rate-risk';

        // Updated analysis configuration with new KRI options
        const analysisConfig = {
        'rate-risk': {
            name: 'Rate Risk Management Strategy',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Risk is present when there is a repricing term mismatch between assets and liabilities. If the volume and the term of these opposing balances were equal and priced off of the same indexes, theoretically there would be no interest rate risk. The reality, however, is that there is a mismatch. Gap is one technique for measuring this mismatch; Plansmith's Risk Management Bubbles is another. The Bubbles method is like a visual Gap report; however, there are 3 differences. 1) Bubbles are easier to understand, 2) bubbles account for the entire term of the bank's position, and 3) by including the current Yield Curve the risk management strategy is more apparent.

    There are also 3 elements in the Bubbles method: 1) The term and yield of assets (The yields are not tax equivalent), 2) the term and cost of liabilities, and 3) the Yield Curve. Now we can quantify the components of the margin; the Asset Benefit (the vertical distance from the Asset Bubble to the Yield Curve), the Deposit Benefit (the distance from the Liability Bubble to the Yield Curve), and the Basis Risk Component (the vertical distance in the Yield Curve between Asset and Liability Bubbles). Dividing the Basis Risk Component (basis points) by the Duration Mismatch (months) quantifies the Risk / Reward Trade-Off.`
        },
        'net-interest': {
            name: 'Net Interest Margin Simulations',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `The Gap Analysis provides the basis for more detailed analysis in the simulation model. Also, gap results are popular rate risk indicators. However, to truly evaluate the impact of rate change on income, simulation is the best technique because variables are changed for the various rate conditions. Each category's interest change is calculated as rates move up and down. In addition, the repayment speeds and repricing speeds are changed.

    Rate Shock is a method for stress testing the Net Interest Margin (NIM) over the next four quarters under several rate change levels. These levels span 100bp increments up and down from the current interest rates. In order to simulate activity, maturing balances are replaced with the new balances at the new rate level, and repricing balances are adjusted to the new rate shock level. The interest is recalculated for each level along with the new average yield. NIM is then calculated and a margin risk profile is developed. The results of these calculations can be seen in the chart below.`
        },
        'forecast-kri': {
            name: 'Forecast Key Risk Indicators',
            csvFile: 'gps_kri_forecast.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Key Risk Indicators (KRI) Forecast Analysis provides forward-looking strategic narrative insights about risk trajectory over a 3-year forecast period. This analysis creates compelling risk evolution stories that inform strategic decision-making rather than summarizing data points.

    The KRI Forecast Narrative focuses on risk trajectory storytelling across the CAELS framework (Capital, Asset Quality, Earnings, Liquidity, and Sensitivity to Market Risk). Rather than describing current risk status, this analysis interprets how risk patterns evolve, interconnect, and influence business strategy over time. The narrative connects individual metric trends to broader strategic themes including capital planning implications, regulatory compliance trajectory, market positioning challenges, and management priority shifts indicated by forecast patterns.

    This forward-looking analysis emphasizes strategic storytelling about compound risk interactions, critical inflection points where risk trajectories change, and business model sustainability implications. The goal is strategic risk narrative that guides leadership decision-making rather than data reporting.`
        },
        'competitive-kri': {
            name: 'Competitive Key Risk Indicators',
            csvFile: 'gps_kri_competitive.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Competitive Key Risk Indicators (KRI) Analysis benchmarks your bank's risk profile against strategic peer groups and industry standards. This analysis provides context for risk-based decision making by comparing your bank's performance across CAELS risk categories relative to peer medians, quartile rankings, and industry benchmarks.

    The Competitive KRI Report examines your bank's relative risk position across all major risk categories: Capital strength vs peers, Asset Quality comparisons with peer banks of similar size and market focus, Earnings stability and profitability metrics relative to peer performance, Liquidity position compared to peer funding strategies, and Interest Rate Risk sensitivity benchmarked against similar institutions. This peer-relative analysis helps identify where your bank's risk profile diverges from industry norms and provides strategic context for risk tolerance decisions and performance objectives.`
        },
        'rate-risk-minimal': {
            name: 'Rate Risk (Minimal)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes — how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.`
        },
        'net-interest-minimal': {
            name: 'Net Interest Margin (Minimal)',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Net Interest Income and margin impacts — how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.`
        },
        'rate-risk-minimal-docs': {
            name: 'Rate Risk (Minimal + Docs)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes — how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.`
        },
        'net-interest-minimal-docs': {
            name: 'Net Interest Margin (Minimal + Docs)',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Net Interest Income and margin impacts — how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.`
        }
    };

        // Initialize on load
        loadActiveAnalysisData();

        // Dropdown change handler
        analysisDropdown.addEventListener('change', (e) => {
            const newAnalysis = e.target.value;
            if (newAnalysis !== activeAnalysis) {
                switchAnalysis(newAnalysis);
            }
        });

        function switchAnalysis(analysisId) {
            activeAnalysis = analysisId;
            
            // Reset to initial state and load new data
            resetToInitialState();
            loadActiveAnalysisData();
        }

        // Refresh button
        refreshButton.addEventListener('click', () => {
            resetToInitialState();
            loadActiveAnalysisData();
        });

        function resetToInitialState() {
            // Reset UI state
            analyzeCenter.classList.remove('hidden');
            chatInterface.classList.remove('active');
            
            // Clear chat messages
            chatMessages.innerHTML = '';
            
            // Reset input
            messageInput.value = '';
            messageInput.disabled = false;
            sendButton.disabled = false;
            
            // Hide any error/success messages
            document.querySelectorAll('.error-message, .success-message').forEach(msg => {
                if (msg.parentNode) msg.remove();
            });
        }

        async function loadActiveAnalysisData() {
            const config = analysisConfig[activeAnalysis];
            
            // Only load sample data if no user data is already loaded
            if (isUserUploadedData()) {
                console.log('User data already loaded, keeping current data');
                return; // Don't overwrite user data with sample data
            }
            
            // Load CSV data (sample data)
            try {
                const csvResponse = await fetch(`./assets/${config.csvFile}`);
                
                if (csvResponse.ok) {
                    const csvText = await csvResponse.text();
                    currentCsvData = parseAndPreprocessCSV(csvText, activeAnalysis);
                    currentDataType = 'csv';
                    csvFileName.textContent = config.csvFile;
                    csvStatus.textContent = 'Active (Sample)';
                    currentCsvFile.classList.remove('no-file-state');
                    currentCsvFile.style.borderColor = '#e1e5e9'; // Default border for sample data
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[CSV] Sample loaded: ${config.csvFile} (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount})`);
                    } catch (_) {}
                } else {
                    showError(`${config.csvFile} not found in assets folder`);
                    csvStatus.textContent = 'Missing';
                    currentCsvFile.classList.add('no-file-state');
                    console.warn(`[CSV] Sample missing: ${config.csvFile}`);
                }
            } catch (error) {
                console.error('Error loading CSV data:', error);
                showError('Could not load CSV data');
                csvStatus.textContent = 'Error';
                currentCsvFile.classList.add('no-file-state');
            }

            // Load PDF data (only if a sample PDF is configured)
            const currentPdfName = pdfFileName.textContent;
            if (currentPdfName && !currentPdfName.includes('sample_') && !currentPdfName.includes('No PDF')) {
                console.log('User PDF already loaded, keeping current PDF');
                return; // Don't overwrite user PDF
            }

            if (analysisConfig[activeAnalysis].pdfFile) {
                try {
                    const pdfResponse = await fetch(`./assets/${config.pdfFile}`);
                    
                    if (pdfResponse.ok) {
                        const pdfBlob = await pdfResponse.blob();
                        currentPdfData = pdfBlob;
                        pdfFileName.textContent = config.pdfFile;
                        pdfStatus.textContent = 'Active (Sample)';
                        currentPdfFile.classList.remove('no-file-state');
                        currentPdfFile.style.borderColor = '#e1e5e9'; // Default border for sample data
                        removePdfBtn.style.display = 'flex';
                        console.log(`[PDF] Sample loaded: ${config.pdfFile} (size=${pdfBlob.size} bytes)`);
                    } else {
                        currentPdfData = null;
                        pdfFileName.textContent = 'No PDF loaded';
                        pdfStatus.textContent = 'Optional';
                        currentPdfFile.classList.add('no-file-state');
                        currentPdfFile.style.borderColor = '#e1e5e9';
                        removePdfBtn.style.display = 'none';
                        console.warn(`[PDF] Sample not found: ${config.pdfFile}`);
                    }
                } catch (error) {
                    console.error('Error loading PDF data:', error);
                    currentPdfData = null;
                    pdfFileName.textContent = 'No PDF loaded';
                    pdfStatus.textContent = 'Optional';
                    currentPdfFile.classList.add('no-file-state');
                    removePdfBtn.style.display = 'none';
                }
            } else {
                currentPdfData = null;
                pdfFileName.textContent = 'No PDF loaded';
                pdfStatus.textContent = 'Optional';
                currentPdfFile.classList.add('no-file-state');
                removePdfBtn.style.display = 'none';
                console.log('[PDF] No sample PDF configured for this analysis');
            }
        }
        // Enhanced CSV parsing and preprocessing for KRI data
        function parseAndPreprocessCSV(csvText, analysisType) {
            try {
                const data = parseCSVRobust(csvText);
                
                // Apply KRI-specific preprocessing
                if (analysisType.includes('kri')) {
                    return preprocessKRIData(data, analysisType);
                }
                
                return data;
                
            } catch (error) {
                console.error('CSV parsing error:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        // KRI-specific data preprocessing
        function preprocessKRIData(data, analysisType) {
            if (!data || data.length === 0) return data;
            
            console.log('Preprocessing KRI data...');
            
            // Clean and normalize column headers
            const processedData = data.map(row => {
                const cleanRow = {};
                
                Object.keys(row).forEach(key => {
                    // Clean column headers
                    let cleanKey = key.trim()
                        .replace(/\s+/g, ' ') // Normalize spaces
                        .replace(/[^\w\s%()/-]/g, '') // Remove special chars except common ones
                        .trim();
                    
                    // Normalize common KRI column patterns
                    if (cleanKey.toLowerCase().includes('risk status')) {
                        cleanKey = 'Risk Status';
                    } else if (cleanKey.toLowerCase().includes('risk trend')) {
                        cleanKey = 'Risk Trend';
                    } else if (cleanKey.toLowerCase().includes('risk outlook')) {
                        cleanKey = 'Risk Outlook';
                    } else if (cleanKey.toLowerCase().includes('current')) {
                        cleanKey = 'Current Value';
                    } else if (cleanKey.toLowerCase().includes('peer') && cleanKey.toLowerCase().includes('median')) {
                        cleanKey = 'Peer Median';
                    }
                    
                    // Clean and standardize cell values
                    let value = row[key];
                    if (typeof value === 'string') {
                        value = value.trim();
                        
                        // Standardize risk levels
                        if (value.toLowerCase() === 'low' || value.toLowerCase() === 'low risk') {
                            value = 'Low';
                        } else if (value.toLowerCase() === 'moderate' || value.toLowerCase() === 'moderate risk') {
                            value = 'Moderate';
                        } else if (value.toLowerCase() === 'high' || value.toLowerCase() === 'high risk') {
                            value = 'High';
                        }
                        
                        // Standardize trend indicators
                        if (value.toLowerCase() === 'increasing') {
                            value = 'Increasing';
                        } else if (value.toLowerCase() === 'decreasing') {
                            value = 'Decreasing';
                        } else if (value.toLowerCase() === 'stable') {
                            value = 'Stable';
                        } else if (value.toLowerCase() === 'fluctuating') {
                            value = 'Fluctuating';
                        }
                        
                        // Convert percentage strings to numbers where appropriate
                        if (value.match(/^\d+\.?\d*%$/)) {
                            const numValue = parseFloat(value.replace('%', ''));
                            if (!isNaN(numValue)) {
                                cleanRow[cleanKey + ' (%)'] = numValue;
                                cleanRow[cleanKey] = value; // Keep original format too
                                return;
                            }
                        }
                    }
                    
                    cleanRow[cleanKey] = value;
                });
                
                return cleanRow;
            });
            
            // Add metadata for better AI understanding
            const metadata = {
                dataType: 'KRI',
                analysisType: analysisType,
                categories: extractKRICategories(processedData),
                riskMetrics: extractRiskMetrics(processedData),
                timeHorizon: analysisType.includes('forecast') ? 'Forecast (3 years)' : 'Current vs Peers',
                processingNotes: 'Data normalized for risk levels (Low/Moderate/High) and trends (Increasing/Decreasing/Stable/Fluctuating)'
            };
            
            console.log('KRI preprocessing complete:', metadata);
            
            // Return data with metadata
            processedData.metadata = metadata;
            return processedData;
        }

        function isUserUploadedData() {
            // More comprehensive check for user data
            const fileName = csvFileName.textContent.toLowerCase();
            return !fileName.includes('sample_') && 
                !fileName.includes('gps_') && 
                !fileName.includes('demo') && 
                !fileName.includes('example') &&
                fileName !== 'no csv loaded';
        }

        function extractKRICategories(data) {
            const categories = new Set();
            
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    const lowerKey = key.toLowerCase();
                    if (lowerKey.includes('capital')) categories.add('Capital');
                    if (lowerKey.includes('asset') || lowerKey.includes('credit') || lowerKey.includes('npl') || lowerKey.includes('texas')) categories.add('Asset Quality');
                    if (lowerKey.includes('earnings') || lowerKey.includes('nim') || lowerKey.includes('roa') || lowerKey.includes('roe')) categories.add('Earnings');
                    if (lowerKey.includes('liquid') || lowerKey.includes('funding')) categories.add('Liquidity');
                    if (lowerKey.includes('rate') || lowerKey.includes('market') || lowerKey.includes('duration')) categories.add('Market Risk');
                });
            });
            
            return Array.from(categories);
        }

        function extractRiskMetrics(data) {
            const metrics = new Set();
            
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (key !== 'Risk Status' && key !== 'Risk Trend' && key !== 'Risk Outlook') {
                        metrics.add(key);
                    }
                });
            });
            
            return Array.from(metrics).slice(0, 10); // Limit to first 10 for brevity
        }

        // File upload handling (keeping existing logic)
        csvFileInput.addEventListener('change', (e) => handleFileUpload(e, 'csv'));
        pdfFileInput.addEventListener('change', (e) => handleFileUpload(e, 'pdf'));
        
        // Remove PDF functionality
        removePdfBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removePdf();
        });

        function removePdf() {
            currentPdfData = null;
            pdfFileName.textContent = 'No PDF loaded';
            pdfStatus.textContent = 'Optional';
            currentPdfFile.classList.add('no-file-state');
            removePdfBtn.style.display = 'none';
            pdfFileInput.value = '';
            showSuccess('PDF removed successfully');
        }
        
        document.querySelectorAll('.change-file-wrapper').forEach(wrapper => {
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        });
        
        async function handleFileUpload(event, fileType) {
            const file = event.target.files[0];
            if (!file) return;

            const fileExtension = file.name.split('.').pop().toLowerCase();
            
            if (fileType === 'csv') {
                if (!['csv', 'xlsx', 'json'].includes(fileExtension)) {
                    showError('Please upload a CSV, Excel (.xlsx), or JSON file');
                    return;
                }
            } else if (fileType === 'pdf') {
                if (fileExtension !== 'pdf') {
                    showError('Please upload a PDF file');
                    return;
                }
            }

            try {
                if (fileType === 'csv') {
                    let data;
                    
                    switch (fileExtension) {
                        case 'csv':
                            const fileContent = await readFileWithEncodingDetection(file);
                            data = parseAndPreprocessCSV(fileContent, activeAnalysis);
                            break;
                        case 'json':
                            const jsonContent = await readFileAsText(file);
                            data = JSON.parse(jsonContent);
                            break;
                        case 'xlsx':
                            showError('Excel files require additional processing. Please convert to CSV for now.');
                            return;
                    }

                    // CRITICAL: Replace the current data completely, don't merge
                    currentCsvData = data;
                    currentDataType = fileExtension;
                    csvFileName.textContent = file.name;
                    csvStatus.textContent = 'Active (User Data)'; // Make it clear this is user data
                    currentCsvFile.classList.remove('no-file-state');
                    
                    // Add visual indicator for user data
                    currentCsvFile.style.borderColor = '#28a745'; // Green border for user data
                    
                    showSuccess(`${file.name} loaded successfully! Analysis will use your institution's data.`);
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[CSV] User file loaded: ${file.name} (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount})`);
                    } catch (_) {}
                } else if (fileType === 'pdf') {
                    currentPdfData = file;
                    pdfFileName.textContent = file.name;
                    pdfStatus.textContent = 'Active (User Data)';
                    currentPdfFile.classList.remove('no-file-state');
                    currentPdfFile.style.borderColor = '#28a745'; // Green border for user data
                    removePdfBtn.style.display = 'flex';
                    
                    showSuccess(`${file.name} loaded successfully!`);
                    console.log(`[PDF] User file loaded: ${file.name} (size=${file.size} bytes)`);
                }
                
            } catch (error) {
                console.error('File processing error:', error);
                showError('Error processing file. Please check the format.');
            }
        }
        // Keep all existing utility functions (readFileWithEncodingDetection, parseCSVRobust, etc.)
        async function readFileWithEncodingDetection(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    let content = e.target.result;
                    
                    if (content.includes('�')) {
                        console.log('Encoding issue detected, trying alternative method...');
                        
                        const reader2 = new FileReader();
                        reader2.onload = function(e2) {
                            resolve(e2.target.result);
                        };
                        reader2.onerror = reject;
                        reader2.readAsText(file, 'ISO-8859-1');
                    } else {
                        resolve(content);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8');
            });
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function parseCSVRobust(csvText) {
            try {
                const lines = csvText.trim().split('\n');
                
                if (lines.length === 0) {
                    throw new Error('Empty CSV file');
                }
                
                const rawData = parseRawCSV(lines);
                
                if (shouldTransposeData(rawData)) {
                    console.log('Detected rate shock format - transposing data...');
                    return transposeCSVData(rawData);
                }
                
                return rawData;
                
            } catch (error) {
                console.error('CSV parsing error:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        function parseRawCSV(lines) {
            const headerLine = lines[0];
            let headers;
            
            if (headerLine.includes('"')) {
                headers = headerLine.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
                headers = headers.map(h => h.replace(/^"|"$/g, '').trim());
            } else {
                headers = headerLine.split(',').map(h => h.trim());
            }
            
            const dataRows = lines.slice(1).filter(line => line.trim().length > 0);
            
            return dataRows.map((line, rowIndex) => {
                let values;
                
                if (line.includes('"')) {
                    values = line.match(/"([^"]*)"|([^,]+)/g) || [];
                    values = values.map(v => {
                        if (v.startsWith('"') && v.endsWith('"')) {
                            return v.slice(1, -1);
                        }
                        return v.trim();
                    });
                } else {
                    values = line.split(',').map(v => v.trim());
                }
                
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                
                return row;
            });
        }

        function shouldTransposeData(data) {
            if (!data || data.length === 0) return false;
            
            const firstRow = data[0];
            const headers = Object.keys(firstRow);
            
            const rateShockPattern = /^[+-]?\d+bp$/i;
            const currentPattern = /^current$/i;
            
            const hasRateShockHeaders = headers.some(header => 
                rateShockPattern.test(header) || currentPattern.test(header)
            );
            
            const firstColumnName = headers[0];
            const isGenericFirstColumn = !firstColumnName || 
                firstColumnName.toLowerCase().includes('rate') ||
                firstColumnName.toLowerCase().includes('shock');
            
            return hasRateShockHeaders && isGenericFirstColumn;
        }

        function transposeCSVData(originalData) {
            if (!originalData || originalData.length === 0) return originalData;
            
            const originalHeaders = Object.keys(originalData[0]);
            const firstColumnName = originalHeaders[0];
            const rateShockColumns = originalHeaders.slice(1);
            
            const transposedData = [];
            
            rateShockColumns.forEach(rateShock => {
                const newRow = {
                    [firstColumnName]: rateShock
                };
                
                originalData.forEach(originalRow => {
                    const categoryName = originalRow[firstColumnName];
                    const value = originalRow[rateShock];
                    if (categoryName) {
                        newRow[categoryName] = value;
                    }
                });
                
                transposedData.push(newRow);
            });
            
            return transposedData;
        }

        function createDetailedDataContext(data, analysisType) {
            let context = `COMPLETE DATASET ANALYSIS (${data.length} rows):\n\n`;
            
            // Add metadata if available
            if (data.metadata) {
                context += `DATA TYPE: ${data.metadata.dataType}\n`;
                context += `ANALYSIS: ${data.metadata.analysisType}\n`;
                context += `TIME HORIZON: ${data.metadata.timeHorizon}\n`;
                if (data.metadata.categories.length > 0) {
                    context += `RISK CATEGORIES: ${data.metadata.categories.join(', ')}\n`;
                }
                context += `PREPROCESSING: ${data.metadata.processingNotes}\n\n`;
            }
            
            context += `COLUMNS: ${Object.keys(data[0]).join(', ')}\n\n`;
            
            context += `COMPLETE DATASET:\n`;
            data.forEach((row, index) => {
                context += `Row ${index + 1}: ${JSON.stringify(row)}\n`;
            });
            
            context += `\n- All ${data.length} rows of data are provided above - use the complete dataset for analysis\n- Calculate percentage changes and dollar amounts from the actual data`;
            
            return context;
        }

        // Minimal data block: just columns and rows, no extra instructions
        function createMinimalDataBlock(data) {
            if (!Array.isArray(data) || data.length === 0) return 'DATASET: (no rows)';
            let block = `DATASET (${data.length} rows)\nCOLUMNS: ${Object.keys(data[0]).join(', ')}\n`;
            data.forEach((row, idx) => {
                block += `Row ${idx + 1}: ${JSON.stringify(row)}\n`;
            });
            return block;
        }

        // Detect dataset type from columns to prevent cross-type analysis
        function detectDataTypeFromColumns(data) {
            if (!Array.isArray(data) || data.length === 0) return 'unknown';
            const headers = Object.keys(data[0]).map(h => (h || '').toLowerCase());
            const hasEve = headers.some(h => h.includes('eve') || h.includes('economic value')) || headers.includes('assets (ev)'.toLowerCase());
            const hasNim = headers.some(h => h.includes('nim') || h.includes('net interest income'));
            const hasKri = headers.some(h => h.includes('risk status') || h.includes('risk trend') || h.includes('risk outlook'));
            if (hasKri) return 'kri';
            if (hasEve) return 'eve';
            if (hasNim) return 'nim';
            return 'unknown';
        }

        function deriveTitleFromType(detectedType) {
            switch (detectedType) {
                case 'nim':
                    return 'Net Interest Margin Analysis';
                case 'eve':
                    return 'Economic Value of Equity (EVE) Risk Analysis';
                case 'kri':
                    return 'Key Risk Indicators Analysis';
                default:
                    return 'Banking Analytics Summary';
            }
        }

        // Keep all existing modal, chat, and UI functions unchanged...
        // View data modal functions
        currentCsvFile.addEventListener('click', () => showDataModal('csv'));
        currentPdfFile.addEventListener('click', () => showDataModal('pdf'));
        closeModal.addEventListener('click', hideDataModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) hideDataModal();
        });

        function showDataModal(fileType) {
            if (fileType === 'csv') {
                if (!currentCsvData) {
                    showError('No CSV data loaded');
                    return;
                }

                modalTitle.textContent = `${csvFileName.textContent} - Data Preview`;
                
                if (Array.isArray(currentCsvData) && currentCsvData.length > 0) {
                    modalBody.innerHTML = createTableHTML(currentCsvData);
                } else {
                    modalBody.innerHTML = `<div class="json-view">${JSON.stringify(currentCsvData, null, 2)}</div>`;
                }
            } else if (fileType === 'pdf') {
                if (!currentPdfData) {
                    showError('No PDF loaded');
                    return;
                }

                modalTitle.textContent = `${pdfFileName.textContent} - PDF Preview`;
                
                if (currentPdfData instanceof File || currentPdfData instanceof Blob) {
                    const pdfUrl = URL.createObjectURL(currentPdfData);
                    modalBody.innerHTML = `<iframe src="${pdfUrl}" class="pdf-preview" title="PDF Preview"></iframe>`;
                } else {
                    modalBody.innerHTML = `<div class="pdf-preview">PDF preview not available for this file format</div>`;
                }
            }
            
            modalOverlay.style.display = 'flex';
        }

        function hideDataModal() {
            modalOverlay.style.display = 'none';
            // Clean up blob URLs
            const iframe = modalBody.querySelector('iframe');
            if (iframe && iframe.src.startsWith('blob:')) {
                URL.revokeObjectURL(iframe.src);
            }
        }

        function createTableHTML(data) {
            if (!data || data.length === 0) return '<p>No data to display</p>';
            
            const headers = Object.keys(data[0]).filter(key => key !== 'metadata');
            const maxRows = 100;
            const displayData = data.slice(0, maxRows);
            
            let html = '<table class="data-table"><thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            displayData.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header] || ''}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (data.length > maxRows) {
                html += `<p style="margin-top: 10px; color: #666;">Showing first ${maxRows} of ${data.length} rows</p>`;
            }
            
            // Add metadata display if available
            if (data.metadata) {
                html += `<div style="margin-top: 20px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                    <strong>Data Information:</strong><br>
                    Type: ${data.metadata.dataType}<br>
                    Analysis: ${data.metadata.analysisType}<br>
                    Categories: ${data.metadata.categories.join(', ')}<br>
                    Time Horizon: ${data.metadata.timeHorizon}
                </div>`;
            }
            
            return html;
        }

        // Analyze table button
        analyzeTableBtn.addEventListener('click', startAnalysis);

      async function startAnalysis() {
        if (!currentCsvData && !currentPdfData) {
            showError('No data loaded to analyze');
            return;
        }

        analyzeCenter.classList.add('hidden');
        chatInterface.classList.add('active');
        
        const config = analysisConfig[activeAnalysis];
        
        let analysisPrompt = '';
        
        // UPDATE the Forecast KRI section in startAnalysis function
        if (activeAnalysis === 'forecast-kri') {
            // Simplified Forecast KRI with minimal structure guidance
            const detailedContext = currentCsvData ? createDetailedDataContext(currentCsvData, activeAnalysis) : '';
            
            analysisPrompt = `You are analyzing ${config.name} data for BankersGPS banking analytics.

        Context: ${config.context}

        ${detailedContext}

        INSTRUCTIONS:
        - DO NOT provide "Dataset Overview," "Key Status Analysis," "Critical Risk Areas," or "Strategic Risk Recommendations" sections
        - Focus on narrative insights about risk trajectory over the forecast period
        - Use specific data points and bold numbers from the CSV
        - Organize with clear headers and professional formatting
        - Include bullet points when listing specific metrics or action items

        Please provide analysis with these TWO sections:

        ## Risk Trend Analysis
        Analyze the directional patterns and trajectories across CAELS risk categories, focusing on how risk metrics evolve over the forecast period. Use specific numbers from the data and explain what these trends mean strategically.

        ## Strategic Risk Implications  
        Focus on forward-looking business implications and management priorities based on the risk trends identified in the data.

        Use professional formatting with headers, bullet points where appropriate, and bold specific numbers and percentages from the dataset.`;
            
        } else {
            // FOR ALL OTHER ANALYSIS TYPES
            // Replace the long analysisPrompt section in startAnalysis() with this:

            if (currentCsvData) {
            const detailedContext = createDetailedDataContext(currentCsvData, activeAnalysis);
            
            analysisPrompt = `Provide a brief, high-level analysis of this ${config.name} data.

            ${detailedContext}

            Keep it simple and concise:

            ## What This Data Shows
            Brief overview of the dataset and key metrics.

            ## Key Findings  
            • 3-4 bullet points highlighting what's happening in the data
            • Use actual numbers and percentages from the dataset
            • Keep each point to 1-2 sentences

            ## Main Takeaway
            One paragraph summary of the overall situation and what it means.

            Focus on explaining what's happening rather than detailed methodology.`;
            }
            else if (currentPdfData) {
                // PDF only case
                analysisPrompt = `You are analyzing ${config.name} data from the uploaded PDF report for BankersGPS banking analytics.

    Context: ${config.context}

    Please extract and analyze the relevant financial data from the uploaded PDF report, focusing on the specific institution's metrics and values.`;
            }
        }

        await sendMessage(analysisPrompt, false);
        messageInput.focus();
    }
        // Keep all existing chat functions (addMessage, formatBotResponse, sendMessage, etc.)
        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'bot'}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = isUser ? escapeHtml(content) : formatBotResponse(content);
            
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatBotResponse(text) {
            let formatted = text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/^#### (.*$)/gm, '<h4>$1</h4>')
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`([^`]+)`/g, '<code>$1</code>');

            formatted = formatted.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');

            const sections = formatted.split(/\n\n+/);
            
            return sections
                .map(section => {
                    section = section.trim();
                    if (!section) return '';
                    
                    if (section.includes('•') || section.match(/^[-*]\s/m)) {
                        return processBulletSection(section);
                    }
                    
                    if (section.startsWith('<h') || section.startsWith('<blockquote>')) {
                        return section;
                    }
                    
                    return `<p>${section.replace(/\n/g, ' ')}</p>`;
                })
                .join('');
        }
        
        function processBulletSection(section) {
            const lines = section.split('\n');
            let result = '';
            let inMainList = false;
            let inSubList = false;
            let currentMainItem = '';
            let subItems = [];
            
            for (let line of lines) {
                line = line.trim();
                
                if (line.match(/^[•*-]\s/)) {
                    if (inSubList && subItems.length > 0) {
                        currentMainItem += '<ul>' + subItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                        subItems = [];
                        inSubList = false;
                    }
                    
                    if (currentMainItem) {
                        result += `<li>${currentMainItem}</li>`;
                        currentMainItem = '';
                    }
                    
                    if (!inMainList) {
                        result = '<ul>';
                        inMainList = true;
                    }
                    
                    currentMainItem = line.replace(/^[•*-]\s/, '');
                    
                } else if (line.match(/^[•*-]\s/) && currentMainItem && !line.includes('<strong>')) {
                    if (!inSubList) {
                        inSubList = true;
                    }
                    subItems.push(line.replace(/^[•*-]\s/, ''));
                    
                } else if (line && currentMainItem) {
                    currentMainItem += ' ' + line;
                }
            }
            
            if (inSubList && subItems.length > 0) {
                currentMainItem += '<ul>' + subItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
            }
            
            if (currentMainItem) {
                result += `<li>${currentMainItem}</li>`;
            }
            
            if (inMainList) {
                result += '</ul>';
            }
            
            return result;
        }

        function showTyping() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot';
            typingDiv.id = 'typing-indicator';
            
            const typingContent = document.createElement('div');
            typingContent.className = 'typing-indicator';
            typingContent.style.display = 'block';
            typingContent.innerHTML = `
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            
            typingDiv.appendChild(typingContent);
            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideTyping() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            
            if (chatInterface.classList.contains('active')) {
                chatMessages.appendChild(errorDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } else {
                document.querySelector('.file-upload-section').appendChild(errorDiv);
            }
            
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;
            
            document.querySelector('.file-upload-section').appendChild(successDiv);
            
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.remove();
                }
            }, 3000);
        }

        async function sendMessage(prompt = null, showUserMessage = true) {
            const message = prompt || messageInput.value.trim();
            if (!message) return;

            if (showUserMessage) {
                addMessage(message, true);
            }
            
            if (!prompt) {
                messageInput.value = '';
            }
            
            messageInput.disabled = true;
            sendButton.disabled = true;
            showTyping();

            try {
                const config = analysisConfig[activeAnalysis];
                let fullPrompt = message;
                
                // CSV data is primary: ALWAYS include it when available
                if (currentCsvData) {
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[SEND] Attaching CSV dataset (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount}) for analysis='${activeAnalysis}'`);
                    } catch (_) {}
                    // Minimal modes: exact prompt from config + dataset only (always include dataset)
                    if (activeAnalysis.includes('-minimal')) {
                        const minimalInstruction = analysisConfig[activeAnalysis].minimalPrompt || '';
                        const minimalData = createMinimalDataBlock(currentCsvData);
                        const userIntent = prompt && showUserMessage ? `\n\nUser Question: ${message}\n` : '';

                        // Add strict guardrails to force citing only dataset values
                        const detectedType = detectDataTypeFromColumns(currentCsvData);
                        const title = deriveTitleFromType(detectedType);
                        let strictRules = `\n\nFORMAT & DATA RULES:\n- Begin with the header: ## ${title}.\n- Only cite numbers that appear verbatim in the DATASET.\n- When citing a figure, reference the scenario and column in natural prose (e.g., Net Interest Income at -400bp is 29,098).\n- If a metric is not present as a column, write "Not available".\n- Do not introduce concepts outside the dataset type. For NIM datasets, do NOT mention EVE/economic value. For EVE datasets, do NOT mention NIM/Net Interest unless a column exists.\n- Keep analysis tied to actual rows (e.g., -400bp, Current, +400bp).`;

                        // Add dataset type hint to align the model
                        if (detectedType !== 'unknown') {
                            strictRules += `\nDATASET TYPE DETECTED: ${detectedType.toUpperCase()} (derived from column headers). Align analysis accordingly.`;
                        }

                        fullPrompt = `${minimalInstruction}${strictRules}${userIntent}\n\n${minimalData}`;
                        // OVERRIDE: Respect exact minimal prompt with dataset only (no extra rules)
                        {
                            const _mi = analysisConfig[activeAnalysis].minimalPrompt || '';
                            const _md = createMinimalDataBlock(currentCsvData);
                            const _ui = prompt && showUserMessage ? `\n\nUser Question: ${message}\n` : '';
                            fullPrompt = `${_mi}${_ui}\n\n${_md}`;
                        }
                    } else {
                        // Regular modes: add a concise, structured instruction then attach the dataset block
                        const detailedContext = createDetailedDataContext(currentCsvData, activeAnalysis);
                        let instruction;
                        if (activeAnalysis.includes('net-interest')) {
                            instruction = `Using only the dataset below (and any uploaded report), write an executive narrative in natural paragraphs. Explain what happens, why, and how across rate shocks (-400 to +400 bps), not just the figures.\n\n- Overall shape: describe earnings sensitivity and any asymmetry (losses in cuts vs gains in hikes).\n- Most adverse: name the scenario and list NIM change (bps) and NII change ($), then one sentence on the driver (e.g., asset yield drop vs liability floors, deposit cost lag).\n- Most favorable: same format, with a one-sentence cause.\n- Higher shocks: note tapering or reversal if visible (e.g., deposit costs accelerate above +200 bps).\n- Drivers: explain asset-side (loans, investments) and liability-side (deposits, borrowings) behavior using patterns in the data (repricing timing, betas, floors, mix shifts).\n\nKeep headings minimal (a single title and a closing “Summary”). Bold important numbers. If a metric isn’t present, state "Not available." End with a short bullet list titled “Assumptions to Review” (3–5 items) tied to observed patterns.`;
                        } else if (activeAnalysis.includes('rate-risk')) {
                            instruction = `Using only the dataset below (and any uploaded report), write an executive narrative in natural paragraphs. Explain what happens, why, and how across shocks (-400 to +400 bps) based on the data.\n\n- Overall shape: describe interest rate sensitivity and whether outcomes are symmetric or skewed.\n- Most adverse: name the scenario and report the magnitude on the key metric(s) present (EVE %, $, or NIM/NII), then one sentence on the main cause (e.g., duration/convexity effects, liability floors).\n- Most favorable: same format, with a one-sentence cause.\n- Higher shocks: note any tapering or reversals; explain with liability repricing acceleration or asset sensitivity.\n- Drivers: explain asset categories and liability categories that matter most, grounded in repricing timing, duration/sensitivity, deposit betas, floors, and mix.\n\nKeep headings minimal (a single title and a closing “Summary”). Bold important numbers. If a metric isn’t present, state "Not available." End with a short bullet list titled “Assumptions to Review” (3–5 items) tied to observed patterns.`;
                        } else {
                            instruction = `Provide a concise executive narrative using only the dataset below. Include an Executive Summary, a section on extremes with magnitudes, primary drivers, and assumptions to review. Bold key figures. If metrics are missing, say "Not available."`;
                        }

                        fullPrompt = `${message}\n\n${instruction}\n\n${detailedContext}`;
                    }
                } else {
                    console.warn(`[SEND] No CSV dataset available to attach for analysis='${activeAnalysis}'. Using PDF/doc context only.`);
                }

                // PDF provides additional institutional context
                // For minimal modes, do not add PDF context
                if (currentPdfData && !activeAnalysis.includes('-minimal')) {
                    fullPrompt += `\n\nADDITIONAL CONTEXT: A PDF report has been uploaded that provides broader institutional context and background for this analysis. Use this as supplementary context to better understand the institution's overall risk profile and strategic position.`;
                }

                // Create FormData for file uploads
                const formData = new FormData();
                formData.append('prompt', fullPrompt);
                formData.append('analysisType', activeAnalysis);
                formData.append('useDocuments', config.useDocuments);

                // Add PDF if available (as supplementary context)
                if (currentPdfData) {
                    formData.append('pdfFile', currentPdfData);
                    formData.append('hasPdf', 'true');
                }

                const response = await fetch('/Chatbot/api/chat', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                hideTyping();

                if (response.ok) {
                    addMessage(data.response);
                } else {
                    showError(data.error || 'Something went wrong');
                }
            } catch (error) {
                hideTyping();
                showError('Network error. Please check your connection.');
                console.error('Error:', error);
            } finally {
                messageInput.disabled = false;
                sendButton.disabled = false;
                if (chatInterface.classList.contains('active')) {
                    messageInput.focus();
                }
            }
        }
        sendButton.addEventListener('click', () => sendMessage());
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    </script>
</body>
</html>
