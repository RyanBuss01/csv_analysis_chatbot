<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BankersGPS Analytics Chatbot</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }

        .chat-container {
            width: 90%;
            max-width: 900px;
            height: 95vh;
            max-height: 95vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            position: relative;
        }

        .analysis-selector {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* analysis label removed */

        .analysis-dropdown {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
            min-width: 200px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23667eea" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px;
            padding-right: 35px;
        }

        .docs-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 10px;
            border-radius: 12px;
            color: #fff;
            font-size: 12px;
            user-select: none;
        }

        .docs-toggle input[type="checkbox"] {
            accent-color: #667eea;
            width: 16px;
            height: 16px;
        }

        

        .refresh-button {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .model-selector {
            position: absolute;
            top: 50%;
            right: 70px; /* leave room for refresh button */
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-dropdown {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
            min-width: 160px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23667eea" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px;
            padding-right: 35px;
        }

        .refresh-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-50%) rotate(180deg);
        }

        .file-upload-section {
            background: #f8f9fa;
            padding: 5px 20px;
            border-bottom: 1px solid #e1e5e9;
            max-height: 100px; /* cap row height similar to original */
            overflow: hidden;
        }

        .file-uploads-container {
            display: flex;
            gap: 14px;
            align-items: stretch;
            flex-wrap: nowrap;
            height: 100%;
        }

        .left-upload-group {
            flex: 1 1 50%;
            max-width: 50%;
            display: flex;
            flex-direction: row; /* place CSV and PDF side-by-side */
            align-items: center;
            gap: 12px;
            height: 100%;
        }

        /* Override default full-width for compact row cards on the left */
        .left-upload-group .current-file {
            width: auto;
            flex: 1 1 0;
            min-width: 0;
        }

        .right-prompt-group {
            flex: 1 1 50%;
            max-width: 50%;
            height: 100%;
            display: flex;
        }

        .upload-square {
            width: 72px;
            height: 72px;
            background: #fff;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: box-shadow .2s ease, border-color .2s ease;
            user-select: none;
        }

        .upload-square:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.08); border-color: #cfd6dd; }
        .upload-square.no-file-state { opacity: .5; border-style: dashed; }

        .upload-square .icon-btn { position: absolute; right: 6px; bottom: 6px; }
        .upload-square .file-icon { font-size: 28px; }

        .prompt-panel {
            flex: 1 1 auto;
            background: #fff;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            padding: 10px 12px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            height: 100%;
            overflow: hidden;
        }

        .prompt-panel .left { display: flex; gap: 10px; align-items: center; }
        .prompt-panel .file-icon { font-size: 22px; }
        .prompt-panel .file-title { font-size: 13px; font-weight: 700; color: #2c3e50; }

        .icon-btn {
            background: transparent;
            border: 1px solid #e1e5e9;
            color: #667eea;
            width: 34px;
            height: 34px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .icon-btn:hover {
            border-color: #667eea;
            background: rgba(102,126,234,0.08);
        }

        .custom-prompt-section { display: none; }

        .custom-prompt-section label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #5a6c7d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        #promptEditor {
            width: 100%;
            min-height: 240px; /* doubled from 120px */
            resize: vertical;
            padding: 10px 12px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.5;
            font-family: inherit;
        }

        .prompt-preview {
            font-size: 13px;
            color: #5a6c7d;
            line-height: 1.45;
            max-height: 6.2em; /* ~4 lines visible in capped row */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
        }

        .file-upload-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-type-label {
            font-size: 12px;
            font-weight: 600;
            color: #5a6c7d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .current-file {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            padding: 8px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            min-height: 60px;
        }

        .current-file:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .file-title-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }

        .file-icon {
            font-size: 18px;
            opacity: 0.8;
        }

        .file-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1 1 auto;
            min-width: 0;
        }

        .file-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
            max-width: 100%;
        }

        .file-status { display: none; }

        .change-file-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .change-file-btn {
            background: transparent;
            color: #667eea;
            border: 1px solid #667eea;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .change-file-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.2);
        }

        .remove-file-btn {
            background: transparent;
            color: #e74c3c;
            border: 1px solid #e74c3c;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-file-btn:hover {
            background: #e74c3c;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.2);
        }

        .no-file-state {
            opacity: 0.6;
            border-style: dashed;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .analyze-center {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            background: #f8f9fa;
        }

        .analyze-center.hidden {
            display: none;
        }

        .analyze-table-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .analyze-table-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.4);
        }

        .chat-interface {
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            min-height: 0;
        }

        .chat-interface.active {
            display: flex;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f8f9fa;
            min-height: 0;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.bot {
            justify-content: flex-start;
        }

        .message-content {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.6;
            word-wrap: break-word;
            font-size: 14px;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message.bot .message-content {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-bottom-left-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* IMPROVED MARKDOWN FORMATTING */
        .message-content h1, .message-content h2, .message-content h3 {
            margin: 12px 0 8px 0;
            color: #2c3e50;
            line-height: 1.4;
        }

        .message-content h1 { 
            font-size: 18px; 
            margin-top: 0;
        }
        
        .message-content h2 { 
            font-size: 16px; 
            margin-top: 16px;
        }
        
        .message-content h3 { 
            font-size: 14px; 
            margin-top: 14px;
        }

        /* IMPROVED PARAGRAPH SPACING */
        .message-content p {
            margin: 12px 0;
            line-height: 1.6;
        }

        /* First paragraph after headers should have less top margin */
        .message-content h1 + p,
        .message-content h2 + p,
        .message-content h3 + p {
            margin-top: 8px;
        }

        /* IMPROVED BULLET POINT FORMATTING */
        .message-content ul, .message-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .message-content li {
            margin: 8px 0;
            line-height: 1.5;
            padding-left: 4px;
        }

        .message-content li strong {
            font-weight: 600;
            color: #2c3e50;
        }

        .message-content ul ul {
            margin: 8px 0 8px 0;
            padding-left: 32px;
        }

        .message-content ul ul li {
            margin: 4px 0;
            font-weight: normal;
        }

        .message-content li p {
            margin: 4px 0;
        }

        .message-content > p {
            padding-left: 0;
            margin-left: 0;
        }

        .message-content em {
            font-style: italic;
            color: #5a6c7d;
        }

        .message-content code {
            background: #f1f1f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .message-content blockquote {
            margin: 16px 0;
            padding: 8px 16px;
            border-left: 4px solid #667eea;
            background: #f8f9fa;
            font-style: italic;
        }

        .typing-indicator {
            display: none;
            padding: 10px 16px;
            background: white;
            border-radius: 18px;
            border-bottom-left-radius: 5px;
            border: 1px solid #e1e5e9;
            max-width: 80px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #999;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e1e5e9;
        }

        .input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            outline: none;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }

        .send-button:hover {
            transform: scale(1.05);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: #ff4757;
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .success-message {
            background: #2ed573;
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 14px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            position: relative;
        }

        /* Wider layout used for the Prompt editor modal only */
        .modal-content.wide {
            width: 80vw;           /* make overlay noticeably wider */
            max-width: 1200px;     /* cap width on large screens */
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .close-modal:hover {
            color: #333;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .data-table th,
        .data-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .data-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .pdf-preview {
            width: 100%;
            height: 500px;
            border: none;
            border-radius: 8px;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #666;
        }

        .json-view {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow: auto;
        }

        .chat-messages::-webkit-scrollbar,
        .modal-content::-webkit-scrollbar,
        .json-view::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .modal-content::-webkit-scrollbar-track,
        .json-view::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .modal-content::-webkit-scrollbar-thumb,
        .json-view::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .modal-content::-webkit-scrollbar-thumb:hover,
        .json-view::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        @media (max-width: 768px) {
            .file-uploads-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .analysis-selector {
                left: 10px;
                flex-direction: column;
                gap: 4px;
            }
            
            .analysis-dropdown {
                min-width: 160px;
                font-size: 10px;
                padding: 6px 12px;
            }
            
            .current-file {
                padding: 8px 16px;
            }
            
            .file-title {
                font-size: 12px;
            }
            
            .change-file-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            .analyze-table-btn {
                padding: 16px 32px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="analysis-selector">
                <select class="analysis-dropdown" id="analysisDropdown">
                    <option value="rate-risk-minimal-2">Rate Risk Management</option>
                    <option value="net-interest-minimal-2" selected>Net Intrest Margin</option>
                    <option value="forecast-kri">Forecast KRI</option>
                    <option value="competitive-kri">Competitive KRI</option>
                </select>
                <label class="docs-toggle" title="Append documentation context">
                    <input type="checkbox" id="addDocsCheckbox" />
                    Add docs
                </label>
            </div>
            <div class="model-selector">
                <select class="model-dropdown" id="modelDropdown" title="Select GPT model">
                    <option value="gpt-4.1-mini" selected>gpt-4.1-mini</option>
                    <option value="gpt-4.1">gpt-4.1</option>
                    <option value="gpt-4o">gpt-4o</option>
                    <option value="gpt-4o-mini">gpt-4o-mini</option>
                    <option value="gpt-5">gpt-5</option>
                </select>
            </div>
            <button class="refresh-button" id="refreshButton" title="Reset Page">üîÑ</button>
        </div>
        
        <div class="file-upload-section">
            <div class="file-uploads-container">
                <div class="left-upload-group">
                    <!-- CSV Original Card -->
                    <div class="current-file" id="currentCsvFile" title="Click to preview CSV">
                        <div class="file-title-section">
                            <div class="file-icon">üìä</div>
                            <div class="file-details">
                                <h4 class="file-title" id="csvFileName">sample_rate_shock.csv</h4>
                                <div class="file-status" id="csvStatus">Active</div>
                            </div>
                        </div>
                        <div class="change-file-wrapper">
                            <div class="file-input-wrapper">
                                <input type="file" id="csvFileInput" class="file-input" accept=".csv,.xlsx,.json">
                                <label for="csvFileInput" class="change-file-btn" title="Change CSV">
                                    <span>üìÑ</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- PDF Original Card -->
                    <div class="current-file" id="currentPdfFile" title="Click to preview PDF">
                        <div class="file-title-section">
                            <div class="file-icon">üìÑ</div>
                            <div class="file-details">
                                <h4 class="file-title" id="pdfFileName">sample_risk_report.pdf</h4>
                                <div class="file-status" id="pdfStatus">Active</div>
                            </div>
                        </div>
                        <div class="change-file-wrapper">
                            <div class="file-input-wrapper">
                                <input type="file" id="pdfFileInput" class="file-input" accept=".pdf">
                                <label for="pdfFileInput" class="change-file-btn" title="Change PDF">
                                    <span>üìÑ</span>
                                </label>
                            </div>
                            <button class="remove-file-btn" id="removePdfBtn" title="Remove PDF">‚úï</button>
                        </div>
                    </div>
                </div>

                <div class="right-prompt-group">
                    <!-- Prompt Panel (right half) -->
                    <div class="prompt-panel">
                        <div class="left">
                            <div class="file-icon">üìù</div>
                            <div>
                                <div class="file-title">Prompt</div>
                                <div class="prompt-preview" id="promptPreview">Edit the analysis prompt‚Ä¶</div>
                            </div>
                        </div>
                        <div style="margin-left:auto;">
                            <button class="icon-btn" id="editPromptBtn" title="Edit prompt">‚úé</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Hidden prompt editor (shown in modal when editing) -->
            <div class="custom-prompt-section">
                <label for="promptEditor">Prompt</label>
                <textarea id="promptEditor" placeholder="Customize the analysis prompt..."></textarea>
            </div>
        </div>
        
        <div class="main-content">
            <div class="analyze-center" id="analyzeCenter">
                <button class="analyze-table-btn" id="analyzeTableBtn">
                    <span>üîç</span>
                    Analyze Data
                </button>
            </div>
            
            <div class="chat-interface" id="chatInterface">
                <div class="chat-messages" id="chatMessages"></div>
                
                <div class="chat-input">
                    <div class="input-container">
                        <input 
                            type="text" 
                            class="message-input" 
                            id="messageInput" 
                            placeholder="Ask about your data or BankersGPS documentation..."
                            maxlength="1000"
                        >
                        <button class="send-button" id="sendButton">
                            ‚û§
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Data Preview</h3>
                <button class="close-modal" id="closeModal">&times;</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const csvFileInput = document.getElementById('csvFileInput');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const currentCsvFile = document.getElementById('currentCsvFile');
        const currentPdfFile = document.getElementById('currentPdfFile');
        const csvFileName = document.getElementById('csvFileName');
        const pdfFileName = document.getElementById('pdfFileName');
        const csvStatus = document.getElementById('csvStatus');
        const pdfStatus = document.getElementById('pdfStatus');
        const removePdfBtn = document.getElementById('removePdfBtn');
        const analyzeCenter = document.getElementById('analyzeCenter');
        const chatInterface = document.getElementById('chatInterface');
        const analyzeTableBtn = document.getElementById('analyzeTableBtn');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const closeModal = document.getElementById('closeModal');
        const modalContent = document.querySelector('.modal-content');
        const refreshButton = document.getElementById('refreshButton');
        const analysisDropdown = document.getElementById('analysisDropdown');
        const modelDropdown = document.getElementById('modelDropdown');
        const promptEditor = document.getElementById('promptEditor');
        const promptPreview = document.getElementById('promptPreview');
        const editPromptBtn = document.getElementById('editPromptBtn');

        let currentCsvData = null;
        let currentPdfData = null;
        let currentDataType = 'csv';
        let activeAnalysis = 'net-interest-minimal-2';
        let includeDocs = false; // 'Add docs' checkbox state
        let selectedModel = 'gpt-4.1-mini';

        // Updated analysis configuration with new KRI options
        const analysisConfig = {
        'rate-risk': {
            name: 'Rate Risk Management Strategy',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Risk is present when there is a repricing term mismatch between assets and liabilities. If the volume and the term of these opposing balances were equal and priced off of the same indexes, theoretically there would be no interest rate risk. The reality, however, is that there is a mismatch. Gap is one technique for measuring this mismatch; Plansmith's Risk Management Bubbles is another. The Bubbles method is like a visual Gap report; however, there are 3 differences. 1) Bubbles are easier to understand, 2) bubbles account for the entire term of the bank's position, and 3) by including the current Yield Curve the risk management strategy is more apparent.

    There are also 3 elements in the Bubbles method: 1) The term and yield of assets (The yields are not tax equivalent), 2) the term and cost of liabilities, and 3) the Yield Curve. Now we can quantify the components of the margin; the Asset Benefit (the vertical distance from the Asset Bubble to the Yield Curve), the Deposit Benefit (the distance from the Liability Bubble to the Yield Curve), and the Basis Risk Component (the vertical distance in the Yield Curve between Asset and Liability Bubbles). Dividing the Basis Risk Component (basis points) by the Duration Mismatch (months) quantifies the Risk / Reward Trade-Off.`
        },
        'net-interest': {
            name: 'Net Interest Margin Simulations',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `The Gap Analysis provides the basis for more detailed analysis in the simulation model. Also, gap results are popular rate risk indicators. However, to truly evaluate the impact of rate change on income, simulation is the best technique because variables are changed for the various rate conditions. Each category's interest change is calculated as rates move up and down. In addition, the repayment speeds and repricing speeds are changed.

    Rate Shock is a method for stress testing the Net Interest Margin (NIM) over the next four quarters under several rate change levels. These levels span 100bp increments up and down from the current interest rates. In order to simulate activity, maturing balances are replaced with the new balances at the new rate level, and repricing balances are adjusted to the new rate shock level. The interest is recalculated for each level along with the new average yield. NIM is then calculated and a margin risk profile is developed. The results of these calculations can be seen in the chart below.`
        },
        'forecast-kri': {
            name: 'Forecast Key Risk Indicators',
            csvFile: 'gps_kri_forecast.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Key Risk Indicators (KRI) Forecast Analysis provides forward-looking strategic narrative insights about risk trajectory over a 3-year forecast period. This analysis creates compelling risk evolution stories that inform strategic decision-making rather than summarizing data points.

    The KRI Forecast Narrative focuses on risk trajectory storytelling across the CAELS framework (Capital, Asset Quality, Earnings, Liquidity, and Sensitivity to Market Risk). Rather than describing current risk status, this analysis interprets how risk patterns evolve, interconnect, and influence business strategy over time. The narrative connects individual metric trends to broader strategic themes including capital planning implications, regulatory compliance trajectory, market positioning challenges, and management priority shifts indicated by forecast patterns.

    This forward-looking analysis emphasizes strategic storytelling about compound risk interactions, critical inflection points where risk trajectories change, and business model sustainability implications. The goal is strategic risk narrative that guides leadership decision-making rather than data reporting.`,
            defaultPrompt: `You are analyzing Forecast KRI data for BankersGPS.\n\nWrite a concise, executive narrative that focuses on forward-looking risk trends across CAELS over the 3-year forecast period. Use actual values from the dataset.\n\nFormat:\n- ## Risk Trend Analysis: Explain directional patterns and inflection points; bold key numbers.\n- ## Strategic Risk Implications: What the trends mean for management priorities.\n\nKeep it strategic and insight-led; avoid table restatement.`
        },
        'competitive-kri': {
            name: 'Competitive Key Risk Indicators',
            csvFile: 'gps_kri_competitive.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            context: `Competitive Key Risk Indicators (KRI) Analysis benchmarks your bank's risk profile against strategic peer groups and industry standards. This analysis provides context for risk-based decision making by comparing your bank's performance across CAELS risk categories relative to peer medians, quartile rankings, and industry benchmarks.

    The Competitive KRI Report examines your bank's relative risk position across all major risk categories: Capital strength vs peers, Asset Quality comparisons with peer banks of similar size and market focus, Earnings stability and profitability metrics relative to peer performance, Liquidity position compared to peer funding strategies, and Interest Rate Risk sensitivity benchmarked against similar institutions. This peer-relative analysis helps identify where your bank's risk profile diverges from industry norms and provides strategic context for risk tolerance decisions and performance objectives.`,
            defaultPrompt: `You are analyzing Competitive KRI data for BankersGPS.\n\nWrite a peer-comparative executive narrative using actual values from the dataset.\n\nFormat:\n- ## Competitive Risk Analysis: Summarize relative position vs peer medians and quartiles; bold key numbers.\n- ## Strategic Positioning: Identify competitive advantages, gaps, and actions.`
        },
        'rate-risk-minimal-2': {
            name: 'Rate Risk (Minimal 2)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes ‚Äî how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.

Executive-style guidance (keep this brief and insight-led, not a table recap):
- Describe overall rate sensitivity and any asymmetry across shocks.
- Name the most adverse and most favorable scenarios; quantify EVE change (%, $) and explain the main drivers.
- Explain which asset and liability categories drive results (e.g., duration/convexity, repricing timing, rate floors, deposit betas) using patterns visible in the data.
- Note any tapering or reversal at higher positive shocks as liability costs/floors pressure results.
- Use minimal headings (a single title and a closing "Summary"). Bold key figures. If a metric isn‚Äôt present, say "Not available." End with 3‚Äì5 bullets titled "Assumptions to Review" tied to observed patterns.`
        },
        'net-interest-minimal-2': {
    name: 'Net Interest Margin (Minimal 2)',
    csvFile: 'sample_net_intrest.csv',
    pdfFile: null,
    useDocuments: false,
    minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

CRITICAL DATA UNITS: Most dollar amounts in the dataset are in thousands (000s), so 29098 = $29.1 million. Only fields labeled "Percent" or "%" are actual percentages. Convert thousands to millions when discussing dollar amounts for clarity.

Note: Focus on Net Interest Income and margin impacts ‚Äî how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.`
},
        'rate-risk-minimal-3': {
            name: 'Rate Risk (Minimal 3: Focused Narrative)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes ‚Äî how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.

Focused explanation and formatting:
- Start with a 2‚Äì3 sentence overview of rate sensitivity and any asymmetry across shocks.
- Extremes: identify the most adverse and most favorable scenarios; quantify EVE change (%, $) and include one sentence on the primary driver for each.
- Drivers: one short paragraph on asset-side dynamics (duration/convexity, repricing timing) and one short paragraph on liability-side dynamics (rate floors, deposit betas, funding mix) grounded in the dataset.
- High-shock behavior: call out any tapering or reversal at higher positive shocks and explain briefly.
- Formatting: single title and a closing "Summary"; natural paragraphs (avoid table restatement); bold key figures; if a metric isn‚Äôt present, write "Not available." End with 3‚Äì5 bullets titled "Assumptions to Review" tied to observed patterns.`
        },
        'net-interest-minimal-3': {
            name: 'Net Interest Margin (Minimal 3: Focused Narrative)',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

        CRITICAL DATA UNITS: Most dollar amounts in the dataset are in thousands (000s), so 29098 = $29.1 million. Only fields labeled "Percent" or "%" are actual percentages. Convert thousands to millions when discussing dollar amounts for clarity.

        Note: Focus on Net Interest Income and margin impacts ‚Äî how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.

        Focused explanation and formatting:
        - Start with a 2‚Äì3 sentence overview of earnings sensitivity and any asymmetry across shocks.
        - Extremes: identify the most adverse and most favorable scenarios; quantify NIM change (bps) and NII change ($) and include one sentence on the primary driver for each.
        - Drivers: one short paragraph on asset-side dynamics (loans and investments; repricing timing) and one short paragraph on liability-side dynamics (deposits and borrowings; deposit betas, rate floors, funding mix) grounded in the dataset.
        - High-shock behavior: call out any tapering or reversal at higher positive shocks as funding costs accelerate.
        - Formatting: single title and a closing "Summary"; natural paragraphs (avoid table restatement); bold key figures; if a metric isn't present, write "Not available." End with 3‚Äì5 bullets titled "Assumptions to Review" tied to observed patterns.`
        },
        'rate-risk-minimal': {
            name: 'Rate Risk (Minimal)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes ‚Äî how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.`
        },
        'net-interest-minimal': {
            name: 'Net Interest Margin (Minimal)',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: null,
            useDocuments: false,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Net Interest Income and margin impacts ‚Äî how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.`
        },
        'rate-risk-minimal-docs': {
            name: 'Rate Risk (Minimal + Docs)',
            csvFile: 'sample_rate_shock.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key risk metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Economic Value of Equity (EVE) changes ‚Äî how the economic value of assets and liabilities changes with interest rates, not balance sheet dollar amounts. The format should be primarily narrative.

Executive-style guidance (keep this brief and insight-led, not a table recap):
- Describe overall rate sensitivity and any asymmetry across shocks.
- Name the most adverse and most favorable scenarios; quantify EVE change (%, $) and explain the main drivers.
- Explain which asset and liability categories drive results (e.g., duration/convexity, repricing timing, rate floors, deposit betas) using patterns visible in the data.
- Note any tapering or reversal at higher positive shocks as liability costs/floors pressure results.
- Use minimal headings (a single title and a closing "Summary"). Bold key figures. If a metric isn‚Äôt present, say "Not available." End with 3‚Äì5 bullets titled "Assumptions to Review" tied to observed patterns.`
        },
        'net-interest-minimal-docs': {
            name: 'Net Interest Margin (Minimal + Docs)',
            csvFile: 'sample_net_intrest.csv',
            pdfFile: 'sample_risk_report.pdf',
            useDocuments: true,
            minimalPrompt: `Using only the uploaded file and no external sources, write a clear, concise and easy-to-read narrative geared towards an executive audience. The narrative should identify key insights across all rate shock scenarios from -400 to +400, including the impact on key metrics and the magnitude of change at the most adverse and favorable scenarios. Include information on the asset and liability categories shown that are having the greatest impact on the results and possible risk assumptions to look into that may contribute to the results.

Note: Focus on Net Interest Income and margin impacts ‚Äî how earnings change with interest rates, including the spread between interest income and funding costs. The format should be primarily narrative.

Executive-style guidance (keep this brief and insight-led, not a table recap):
- Describe overall earnings sensitivity and any asymmetry across shocks.
- Name the most adverse and most favorable scenarios; quantify NIM change (bps) and NII change ($), then explain the primary drivers.
- Identify which asset and liability categories matter most (loans, investments vs deposits, borrowings), referencing repricing timing, deposit betas, and rate floors apparent in the data.
- Note any tapering or reversal at higher positive shocks as funding costs accelerate.
- Use minimal headings (a single title and a closing "Summary"). Bold key figures. If a metric isn‚Äôt present, say "Not available." End with 3‚Äì5 bullets titled "Assumptions to Review" tied to observed patterns.`
        }
    };

        // Initialize on load
        loadActiveAnalysisData();
        loadDefaultPromptForAnalysis();
        updatePromptPreview();

        // Keep KRI options and both minimal-2 modes; no trimming

        // Dropdown change handler
        analysisDropdown.addEventListener('change', (e) => {
            const newAnalysis = e.target.value;
            if (newAnalysis !== activeAnalysis) {
                switchAnalysis(newAnalysis);
            }
        });

        // Docs toggle handler
        const addDocsCheckbox = document.getElementById('addDocsCheckbox');
        addDocsCheckbox.addEventListener('change', (e) => {
            includeDocs = e.target.checked;
            console.log(`[UI] Add docs toggled: ${includeDocs}`);
        });

        // Model dropdown handler
        modelDropdown.addEventListener('change', (e) => {
            selectedModel = e.target.value || 'gpt-4.1-mini';
            console.log(`[UI] Model selected: ${selectedModel}`);
        });

        function switchAnalysis(analysisId) {
            activeAnalysis = analysisId;
            
            // Reset to initial state and load new data
            resetToInitialState();
            loadActiveAnalysisData();
            loadDefaultPromptForAnalysis();
            updatePromptPreview();
        }

        function getDefaultPromptForAnalysis() {
            const config = analysisConfig[activeAnalysis] || {};
            if (activeAnalysis.includes('-minimal')) {
                return config.minimalPrompt || '';
            }
            return config.defaultPrompt || '';
        }

        function loadDefaultPromptForAnalysis() {
            try {
                promptEditor.value = getDefaultPromptForAnalysis();
            } catch (_) {
                promptEditor.value = '';
            }
        }

        function updatePromptPreview() {
            const text = (promptEditor.value || '').trim();
            promptPreview.textContent = text ? text : 'Edit the analysis prompt‚Ä¶';
        }

        editPromptBtn.addEventListener('click', () => {
            openPromptModal();
        });

        function openPromptModal() {
            modalTitle.textContent = 'Edit Prompt';
            // Make the edit prompt modal wider for better editing experience
            modalContent.classList.add('wide');
            // Clear modal body and insert the editor
            modalBody.innerHTML = '';
            promptEditor.style.display = 'block';
            modalBody.appendChild(promptEditor);
            
            // Add actions
            const actions = document.createElement('div');
            actions.style.marginTop = '12px';
            actions.style.display = 'flex';
            actions.style.gap = '8px';
            
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.className = 'change-file-btn';
            saveBtn.addEventListener('click', () => {
                updatePromptPreview();
                modalOverlay.style.display = 'none';
            });
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'remove-file-btn';
            cancelBtn.addEventListener('click', () => closeModal.click());
            
            actions.appendChild(saveBtn);
            actions.appendChild(cancelBtn);
            modalBody.appendChild(actions);
            
            // Show modal
            modalOverlay.style.display = 'flex';
        }

        closeModal.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });

        // Refresh button: perform full page reload; fallback to soft reset
        refreshButton.addEventListener('click', () => {
            try {
                // Attempt a hard reload to fully reset app state
                window.location.reload();
            } catch (err) {
                // Fallback: soft reset to initial state
                console.warn('Hard reload failed; performing soft reset.', err);
                // Reset selects and toggles to defaults
                analysisDropdown.value = 'net-interest-minimal-2';
                activeAnalysis = 'net-interest-minimal-2';
                addDocsCheckbox.checked = false;
                includeDocs = false;
                modelDropdown.value = 'gpt-4.1-mini';
                selectedModel = 'gpt-4.1-mini';

                // Clear prompt editor and reload defaults
                promptEditor.value = '';
                resetToInitialState();
                loadActiveAnalysisData();
                loadDefaultPromptForAnalysis();
                updatePromptPreview();
            }
        });

        function resetToInitialState() {
            // Reset UI state
            analyzeCenter.classList.remove('hidden');
            chatInterface.classList.remove('active');
            
            // Clear chat messages
            chatMessages.innerHTML = '';
            
            // Reset input
            messageInput.value = '';
            messageInput.disabled = false;
            sendButton.disabled = false;
            
            // Hide any error/success messages
            document.querySelectorAll('.error-message, .success-message').forEach(msg => {
                if (msg.parentNode) msg.remove();
            });
        }

        async function loadActiveAnalysisData() {
            const config = analysisConfig[activeAnalysis];
            
            // Only load sample data if no user data is already loaded
            if (isUserUploadedData()) {
                console.log('User data already loaded, keeping current data');
                return; // Don't overwrite user data with sample data
            }
            
            // Load CSV data (sample data)
            try {
                const csvResponse = await fetch(`./assets/${config.csvFile}`);
                
                if (csvResponse.ok) {
                    const csvText = await csvResponse.text();
                    currentCsvData = parseAndPreprocessCSV(csvText, activeAnalysis);
                    currentDataType = 'csv';
                    csvFileName.textContent = config.csvFile;
                    csvStatus.textContent = 'Active (Sample)';
                    currentCsvFile.classList.remove('no-file-state');
                    currentCsvFile.style.borderColor = '#e1e5e9'; // Default border for sample data
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[CSV] Sample loaded: ${config.csvFile} (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount})`);
                    } catch (_) {}
                } else {
                    showError(`${config.csvFile} not found in assets folder`);
                    csvStatus.textContent = 'Missing';
                    currentCsvFile.classList.add('no-file-state');
                    console.warn(`[CSV] Sample missing: ${config.csvFile}`);
                }
            } catch (error) {
                console.error('Error loading CSV data:', error);
                showError('Could not load CSV data');
                csvStatus.textContent = 'Error';
                currentCsvFile.classList.add('no-file-state');
            }

            // Load PDF data (only if a sample PDF is configured)
            const currentPdfName = pdfFileName.textContent;
            if (currentPdfName && !currentPdfName.includes('sample_') && !currentPdfName.includes('No PDF')) {
                console.log('User PDF already loaded, keeping current PDF');
                return; // Don't overwrite user PDF
            }

            if (analysisConfig[activeAnalysis].pdfFile) {
                try {
                    const pdfResponse = await fetch(`./assets/${config.pdfFile}`);
                    
                    if (pdfResponse.ok) {
                        const pdfBlob = await pdfResponse.blob();
                        currentPdfData = pdfBlob;
                        pdfFileName.textContent = config.pdfFile;
                        pdfStatus.textContent = 'Active (Sample)';
                        currentPdfFile.classList.remove('no-file-state');
                        currentPdfFile.style.borderColor = '#e1e5e9'; // Default border for sample data
                        removePdfBtn.style.display = 'flex';
                        console.log(`[PDF] Sample loaded: ${config.pdfFile} (size=${pdfBlob.size} bytes)`);
                    } else {
                        currentPdfData = null;
                        pdfFileName.textContent = 'No PDF loaded';
                        pdfStatus.textContent = 'Optional';
                        currentPdfFile.classList.add('no-file-state');
                        currentPdfFile.style.borderColor = '#e1e5e9';
                        removePdfBtn.style.display = 'none';
                        console.warn(`[PDF] Sample not found: ${config.pdfFile}`);
                    }
                } catch (error) {
                    console.error('Error loading PDF data:', error);
                    currentPdfData = null;
                    pdfFileName.textContent = 'No PDF loaded';
                    pdfStatus.textContent = 'Optional';
                    currentPdfFile.classList.add('no-file-state');
                    removePdfBtn.style.display = 'none';
                }
            } else {
                currentPdfData = null;
                pdfFileName.textContent = 'No PDF loaded';
                pdfStatus.textContent = 'Optional';
                currentPdfFile.classList.add('no-file-state');
                removePdfBtn.style.display = 'none';
                console.log('[PDF] No sample PDF configured for this analysis');
            }
        }
        // Enhanced CSV parsing and preprocessing for KRI data
        function parseAndPreprocessCSV(csvText, analysisType) {
            try {
                const data = parseCSVRobust(csvText, analysisType);
                
                // Apply KRI-specific preprocessing
                if (analysisType.includes('kri')) {
                    return preprocessKRIData(data, analysisType);
                }
                
                return data;
                
            } catch (error) {
                console.error('CSV parsing error:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        // KRI-specific data preprocessing
        function preprocessKRIData(data, analysisType) {
            if (!data || data.length === 0) return data;
            
            console.log('Preprocessing KRI data...');
            
            // Clean and normalize column headers
            const processedData = data.map(row => {
                const cleanRow = {};
                
                Object.keys(row).forEach(key => {
                    // Clean column headers
                    let cleanKey = key.trim()
                        .replace(/\s+/g, ' ') // Normalize spaces
                        .replace(/[^\w\s%()/-]/g, '') // Remove special chars except common ones
                        .trim();
                    
                    // Normalize common KRI column patterns
                    if (cleanKey.toLowerCase().includes('risk status')) {
                        cleanKey = 'Risk Status';
                    } else if (cleanKey.toLowerCase().includes('risk trend')) {
                        cleanKey = 'Risk Trend';
                    } else if (cleanKey.toLowerCase().includes('risk outlook')) {
                        cleanKey = 'Risk Outlook';
                    } else if (cleanKey.toLowerCase().includes('current')) {
                        cleanKey = 'Current Value';
                    } else if (cleanKey.toLowerCase().includes('peer') && cleanKey.toLowerCase().includes('median')) {
                        cleanKey = 'Peer Median';
                    }
                    
                    // Clean and standardize cell values
                    let value = row[key];
                    if (typeof value === 'string') {
                        value = value.trim();
                        
                        // Standardize risk levels
                        if (value.toLowerCase() === 'low' || value.toLowerCase() === 'low risk') {
                            value = 'Low';
                        } else if (value.toLowerCase() === 'moderate' || value.toLowerCase() === 'moderate risk') {
                            value = 'Moderate';
                        } else if (value.toLowerCase() === 'high' || value.toLowerCase() === 'high risk') {
                            value = 'High';
                        }
                        
                        // Standardize trend indicators
                        if (value.toLowerCase() === 'increasing') {
                            value = 'Increasing';
                        } else if (value.toLowerCase() === 'decreasing') {
                            value = 'Decreasing';
                        } else if (value.toLowerCase() === 'stable') {
                            value = 'Stable';
                        } else if (value.toLowerCase() === 'fluctuating') {
                            value = 'Fluctuating';
                        }
                        
                        // Convert percentage strings to numbers where appropriate
                        if (value.match(/^\d+\.?\d*%$/)) {
                            const numValue = parseFloat(value.replace('%', ''));
                            if (!isNaN(numValue)) {
                                cleanRow[cleanKey + ' (%)'] = numValue;
                                cleanRow[cleanKey] = value; // Keep original format too
                                return;
                            }
                        }
                    }
                    
                    cleanRow[cleanKey] = value;
                });
                
                return cleanRow;
            });
            
            // Add metadata for better AI understanding
            const metadata = {
                dataType: 'KRI',
                analysisType: analysisType,
                categories: extractKRICategories(processedData),
                riskMetrics: extractRiskMetrics(processedData),
                timeHorizon: analysisType.includes('forecast') ? 'Forecast (3 years)' : 'Current vs Peers',
                processingNotes: 'Data normalized for risk levels (Low/Moderate/High) and trends (Increasing/Decreasing/Stable/Fluctuating)'
            };
            
            console.log('KRI preprocessing complete:', metadata);
            
            // Return data with metadata
            processedData.metadata = metadata;
            return processedData;
        }

        function isUserUploadedData() {
            // More comprehensive check for user data
            const fileName = csvFileName.textContent.toLowerCase();
            return !fileName.includes('sample_') && 
                !fileName.includes('gps_') && 
                !fileName.includes('demo') && 
                !fileName.includes('example') &&
                fileName !== 'no csv loaded';
        }

        function extractKRICategories(data) {
            const categories = new Set();
            
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    const lowerKey = key.toLowerCase();
                    if (lowerKey.includes('capital')) categories.add('Capital');
                    if (lowerKey.includes('asset') || lowerKey.includes('credit') || lowerKey.includes('npl') || lowerKey.includes('texas')) categories.add('Asset Quality');
                    if (lowerKey.includes('earnings') || lowerKey.includes('nim') || lowerKey.includes('roa') || lowerKey.includes('roe')) categories.add('Earnings');
                    if (lowerKey.includes('liquid') || lowerKey.includes('funding')) categories.add('Liquidity');
                    if (lowerKey.includes('rate') || lowerKey.includes('market') || lowerKey.includes('duration')) categories.add('Market Risk');
                });
            });
            
            return Array.from(categories);
        }

        function extractRiskMetrics(data) {
            const metrics = new Set();
            
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (key !== 'Risk Status' && key !== 'Risk Trend' && key !== 'Risk Outlook') {
                        metrics.add(key);
                    }
                });
            });
            
            return Array.from(metrics).slice(0, 10); // Limit to first 10 for brevity
        }

        // File upload handling (keeping existing logic)
        csvFileInput.addEventListener('change', (e) => handleFileUpload(e, 'csv'));
        pdfFileInput.addEventListener('change', (e) => handleFileUpload(e, 'pdf'));
        
        // Remove PDF functionality
        removePdfBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removePdf();
        });

        function removePdf() {
            currentPdfData = null;
            pdfFileName.textContent = 'No PDF loaded';
            pdfStatus.textContent = 'Optional';
            currentPdfFile.classList.add('no-file-state');
            removePdfBtn.style.display = 'none';
            pdfFileInput.value = '';
            showSuccess('PDF removed successfully');
        }
        
        document.querySelectorAll('.change-file-wrapper').forEach(wrapper => {
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        });
        
        async function handleFileUpload(event, fileType) {
            const file = event.target.files[0];
            if (!file) return;

            const fileExtension = file.name.split('.').pop().toLowerCase();
            
            if (fileType === 'csv') {
                if (!['csv', 'xlsx', 'json'].includes(fileExtension)) {
                    showError('Please upload a CSV, Excel (.xlsx), or JSON file');
                    return;
                }
            } else if (fileType === 'pdf') {
                if (fileExtension !== 'pdf') {
                    showError('Please upload a PDF file');
                    return;
                }
            }

            try {
                if (fileType === 'csv') {
                    let data;
                    
                    switch (fileExtension) {
                        case 'csv':
                            const fileContent = await readFileWithEncodingDetection(file);
                            data = parseAndPreprocessCSV(fileContent, activeAnalysis);
                            break;
                        case 'json':
                            const jsonContent = await readFileAsText(file);
                            data = JSON.parse(jsonContent);
                            break;
                        case 'xlsx':
                            showError('Excel files require additional processing. Please convert to CSV for now.');
                            return;
                    }

                    // CRITICAL: Replace the current data completely, don't merge
                    currentCsvData = data;
                    currentDataType = fileExtension;
                    csvFileName.textContent = file.name;
                    csvStatus.textContent = 'Active (User Data)'; // Make it clear this is user data
                    currentCsvFile.classList.remove('no-file-state');
                    
                    // Add visual indicator for user data
                    currentCsvFile.style.borderColor = '#28a745'; // Green border for user data
                    
                    showSuccess(`${file.name} loaded successfully! Analysis will use your institution's data.`);
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[CSV] User file loaded: ${file.name} (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount})`);
                    } catch (_) {}
                } else if (fileType === 'pdf') {
                    currentPdfData = file;
                    pdfFileName.textContent = file.name;
                    pdfStatus.textContent = 'Active (User Data)';
                    currentPdfFile.classList.remove('no-file-state');
                    currentPdfFile.style.borderColor = '#28a745'; // Green border for user data
                    removePdfBtn.style.display = 'flex';
                    
                    showSuccess(`${file.name} loaded successfully!`);
                    console.log(`[PDF] User file loaded: ${file.name} (size=${file.size} bytes)`);
                }
                
            } catch (error) {
                console.error('File processing error:', error);
                showError('Error processing file. Please check the format.');
            }
        }
        // Keep all existing utility functions (readFileWithEncodingDetection, parseCSVRobust, etc.)
        async function readFileWithEncodingDetection(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    let content = e.target.result;
                    
                    if (content.includes('ÔøΩ')) {
                        console.log('Encoding issue detected, trying alternative method...');
                        
                        const reader2 = new FileReader();
                        reader2.onload = function(e2) {
                            resolve(e2.target.result);
                        };
                        reader2.onerror = reject;
                        reader2.readAsText(file, 'ISO-8859-1');
                    } else {
                        resolve(content);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8');
            });
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function parseCSVRobust(csvText, analysisType) {
            try {
                const normalized = csvText.replace(/\r\n?/g, '\n').trim();
                const lines = normalized.split('\n');
                
                if (lines.length === 0) {
                    throw new Error('Empty CSV file');
                }
                
                const rawData = parseRawCSV(lines);

                // Always normalize orientation for Net Interest / Rate Risk
                const a = (analysisType || '').toLowerCase();
                if (a.includes('net-interest') || a.includes('rate-risk')) {
                    const normalizedData = normalizeBankOrientation(rawData);
                    try {
                        const headers = Object.keys(normalizedData[0] || {});
                        console.log('[CSV] Normalized headers:', headers.join(', '));
                    } catch (_) {}
                    return normalizedData;
                }

                return rawData;
                
            } catch (error) {
                console.error('CSV parsing error:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        function parseRawCSV(lines) {
        const headerLineRaw = lines[0] || '';
        
        // Detect delimiter
        const commaCount = (headerLineRaw.match(/,/g) || []).length;
        const tabCount = (headerLineRaw.match(/\t/g) || []).length;
        const delimiter = tabCount > commaCount ? '\t' : ',';

        // Split CSV line respecting quotes
        const splitRespectingQuotes = (line) => {
            const out = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (!inQuotes && ch === delimiter) {
                    out.push(current);
                    current = '';
                } else {
                    current += ch;
                }
            }
            out.push(current);
            return out.map(v => v.replace(/^\uFEFF/, '').trim());
        };

        // Check if first row contains rate scenarios instead of headers
        const firstRowValues = splitRespectingQuotes(headerLineRaw).map(h => h.replace(/^"|"$/g, '').trim());
        const rateShockPattern = /^[+-]?\d+\s*bp$|^current$/i;
        const rateScenarioCount = firstRowValues.filter(val => rateShockPattern.test(val)).length;

        console.log('CSV PARSING - First row:', firstRowValues);
        console.log('Rate scenarios found:', rateScenarioCount);

        if (rateScenarioCount >= 3) {
            console.log('Treating as headerless CSV - first row contains data');
            
            // Create synthetic column names
            const columnNames = firstRowValues.map((_, index) => `col_${index}`);
            console.log('Synthetic columns:', columnNames);
            
            // Process all lines as data
            const allLines = lines.filter(line => line.trim().length > 0);
            
            const result = allLines.map((line) => {
                const values = splitRespectingQuotes(line);
                const row = {};
                columnNames.forEach((colName, index) => {
                    row[colName] = (values[index] ?? '').replace(/^"|"$/g, '').trim();
                });
                return row;
            });
            
            console.log('Parsed result sample:', result[0]);
            return result;
        } else {
            console.log('Standard CSV with headers');
            const headers = firstRowValues;
            const dataRows = lines.slice(1).filter(line => line.trim().length > 0);

            return dataRows.map((line) => {
                const values = splitRespectingQuotes(line);
                const row = {};
                headers.forEach((header, index) => {
                    const key = header || `Column_${index}`;
                    row[key] = (values[index] ?? '').replace(/^"|"$/g, '').trim();
                });
                return row;
            });
        }
    }

        // Ensure final layout is: first column header 'bp', values like "-400bp/Current/+200bp" down the rows;
        // top headers are category titles taken from the original first column when needed.
        function normalizeBankOrientation(data) {
            if (!Array.isArray(data) || data.length === 0) return data;

            const rateShockPattern = /^[+-]?\d+\s*bp$|^current$/i;
            const headers = Object.keys(data[0] || {});
            const firstKey = headers[0] || '';

            console.log('Normalize Debug - Original headers:', headers);
            console.log('Normalize Debug - First row:', data[0]);

            // Check if first column contains rate scenarios (already correct orientation)
            const sampleCount = Math.min(10, data.length);
            let bpMatches = 0;
            for (let i = 0; i < sampleCount; i++) {
                const v = String(data[i][firstKey] || '').trim();
                if (rateShockPattern.test(v)) bpMatches++;
            }
            const firstColHasRateScenarios = bpMatches >= Math.max(2, Math.ceil(sampleCount * 0.6));

            if (firstColHasRateScenarios) {
                console.log('Data is already in correct format');
                // Do not rename headers; preserve the original first column header (e.g., 'Rate Change')
                return data;
            }

            // Check if FIRST ROW has rate scenarios across multiple columns
            // In your case: Row 1 has -400bp, -300bp, -200bp, etc. going horizontally
            const firstRow = data[0];
            // Exclude a potential label column like 'Column_0' from the scenario scan
            const firstRowValues = headers
                .filter(h => h !== 'Column_0')
                .map(header => String(firstRow[header] || '').trim());
            const firstRowHasRateScenarios = firstRowValues.filter(val => rateShockPattern.test(val)).length >= 3;

            console.log('First row values (excluding last):', firstRowValues);
            console.log('First row has rate scenarios:', firstRowHasRateScenarios);

            if (firstRowHasRateScenarios) {
                console.log('Need to transpose - rate scenarios are in first row');
                return transposeCSVData(data);
            }

            // Fallback cases...
            const headersHaveRateScenarios = headers.some(h => rateShockPattern.test(h));
            if (headersHaveRateScenarios) {
                console.log('Headers have rate scenarios, transposing');
                return transposeCSVData(data);
            }

            if (headers.includes('bp') && headers[0] !== 'bp') {
                console.log('Moving bp column to first position');
                return data.map(row => {
                    const newRow = { bp: row.bp };
                    headers.forEach(key => {
                        if (key !== 'bp') newRow[key] = row[key];
                    });
                    return newRow;
                });
            }

            console.log('No changes needed');
            return data;
        }

        function renameKeyAndMoveFirst(rows, oldKey, newKey) {
            return rows.map(r => {
                const out = {};
                out[newKey] = r[oldKey];
                Object.keys(r).forEach(k => { if (k !== oldKey) out[k] = r[k]; });
                return out;
            });
        }

        function moveKeyFirst(rows, key) {
            return rows.map(r => {
                const out = {};
                out[key] = r[key];
                Object.keys(r).forEach(k => { if (k !== key) out[k] = r[k]; });
                return out;
            });
        }

        function shouldTransposeData(data, analysisType) {
            if (!data || data.length === 0) return false;
            // Only auto-flip for Net Interest and Rate Risk analyses
            const a = (analysisType || '').toLowerCase();
            const flipEligible = a.includes('net-interest') || a.includes('rate-risk');
            if (!flipEligible) return false;

            const firstRow = data[0];
            const headers = Object.keys(firstRow);

            const rateShockPattern = /^[+-]?\d+\s*bp$/i;
            const currentPattern = /^current$/i;

            // Count how many headers (excluding first) look like bp columns or 'Current'
            const bpLikeCount = headers.slice(1).reduce((acc, h) => {
                return acc + (rateShockPattern.test(h) || currentPattern.test(h) ? 1 : 0);
            }, 0);

            // Check if first column already contains bp-like values (meaning it's already correct orientation)
            const firstColKey = headers[0];
            const sampleCount = Math.min(10, data.length);
            let firstColBpMatches = 0;
            for (let i = 0; i < sampleCount; i++) {
                const v = (data[i][firstColKey] || '').toString().trim();
                if (rateShockPattern.test(v) || currentPattern.test(v)) firstColBpMatches++;
            }

            // If first column is already bp-like for most sampled rows, do NOT transpose
            if (firstColBpMatches >= Math.max(2, Math.floor(sampleCount * 0.6))) {
                return false;
            }

            // Heuristic: if at least 2 bp-like headers exist and first column is NOT bp-like, transpose
            return bpLikeCount >= 2;
        }

        function transposeCSVData(originalData) {
            if (!originalData || originalData.length === 0) return originalData;

            console.log('REAL TRANSPOSE - Original structure:');
            console.log('Original headers:', Object.keys(originalData[0]));
            console.log('Original first row:', originalData[0]);
            console.log('Original data rows:', originalData.length);

            // Get the original structure
            const originalHeaders = Object.keys(originalData[0]);
            const lastColumnName = originalHeaders[originalHeaders.length - 1];
            
            // Extract rate scenarios from FIRST ROW (excluding last column which has "Rate Change")
            const rateScenarios = [];
            for (let i = 0; i < originalHeaders.length - 1; i++) {
                const headerName = originalHeaders[i];
                const scenarioValue = originalData[0][headerName];
                if (scenarioValue && String(scenarioValue).trim()) {
                    rateScenarios.push(String(scenarioValue).trim());
                }
            }
            
            // Extract metric names from LAST COLUMN (excluding first row)
            const metricNames = [];
            for (let rowIndex = 1; rowIndex < originalData.length; rowIndex++) {
                const metricName = originalData[rowIndex][lastColumnName];
                if (metricName && String(metricName).trim()) {
                    metricNames.push(String(metricName).trim());
                }
            }

            // Determine the desired first column header name (scenario header),
            // using the value in the first row, last column when available (e.g., 'Rate Change').
            const scenarioHeaderCandidate = originalData[0][lastColumnName] && String(originalData[0][lastColumnName]).trim();
            const scenarioHeaderName = scenarioHeaderCandidate || lastColumnName || 'bp';

            // Exclude the scenario header name from metric columns if it appears there
            const filteredMetricNames = metricNames.filter(m => m.toLowerCase() !== String(scenarioHeaderName).toLowerCase());
            
            console.log('Rate scenarios extracted:', rateScenarios);
            console.log('Metric names extracted:', filteredMetricNames);
            
            // NOW DO THE ACTUAL TRANSPOSE:
            // Create one row per rate scenario, with metrics as columns
            const transposedData = [];
            
            for (let scenarioIndex = 0; scenarioIndex < rateScenarios.length; scenarioIndex++) {
                const scenario = rateScenarios[scenarioIndex];
                const newRow = {};
                newRow[scenarioHeaderName] = scenario;
                
                // For each metric, get its value for this scenario
                for (let metricIndex = 0; metricIndex < filteredMetricNames.length; metricIndex++) {
                    const metricName = filteredMetricNames[metricIndex];
                    
                    // Find the value in the original data:
                    // - Row: metricIndex + 1 (skip the first row which has scenarios)
                    // - Column: scenarioIndex (which scenario column)
                    const sourceRowIndex = metricIndex + 1;
                    const sourceColumnName = originalHeaders[scenarioIndex];
                    
                    const value = originalData[sourceRowIndex] && originalData[sourceRowIndex][sourceColumnName] 
                        ? originalData[sourceRowIndex][sourceColumnName] 
                        : '';
                    
                    newRow[metricName] = value;
                }
                
                transposedData.push(newRow);
            }
            
            console.log('TRANSPOSED RESULT:');
            console.log('New headers:', Object.keys(transposedData[0] || {}));
            console.log('First row:', transposedData[0]);
            console.log('Second row:', transposedData[1]);
            console.log('Total rows:', transposedData.length);
            
            return transposedData;
        }

        function createDetailedDataContext(data, analysisType) {
            let context = `COMPLETE DATASET ANALYSIS (${data.length} rows):\n\n`;
            
            // Add metadata if available
            if (data.metadata) {
                context += `DATA TYPE: ${data.metadata.dataType}\n`;
                context += `ANALYSIS: ${data.metadata.analysisType}\n`;
                context += `TIME HORIZON: ${data.metadata.timeHorizon}\n`;
                if (data.metadata.categories.length > 0) {
                    context += `RISK CATEGORIES: ${data.metadata.categories.join(', ')}\n`;
                }
                context += `PREPROCESSING: ${data.metadata.processingNotes}\n\n`;
            }
            
            context += `COLUMNS: ${Object.keys(data[0]).join(', ')}\n\n`;
            
            context += `COMPLETE DATASET:\n`;
            data.forEach((row, index) => {
                context += `Row ${index + 1}: ${JSON.stringify(row)}\n`;
            });
            
            context += `\n- All ${data.length} rows of data are provided above - use the complete dataset for analysis\n- Calculate percentage changes and dollar amounts from the actual data`;
            
            return context;
        }

        // Minimal data block: just columns and rows, no extra instructions
        function createMinimalDataBlock(data) {
            if (!Array.isArray(data) || data.length === 0) return 'DATASET: (no rows)';
            let block = `DATASET (${data.length} rows)\nCOLUMNS: ${Object.keys(data[0]).join(', ')}\n`;
            data.forEach((row, idx) => {
                block += `Row ${idx + 1}: ${JSON.stringify(row)}\n`;
            });
            return block;
        }

        // Detect dataset type from columns to prevent cross-type analysis
        function detectDataTypeFromColumns(data) {
            if (!Array.isArray(data) || data.length === 0) return 'unknown';
            const headers = Object.keys(data[0]).map(h => (h || '').toLowerCase());
            const hasEve = headers.some(h => h.includes('eve') || h.includes('economic value')) || headers.includes('assets (ev)'.toLowerCase());
            const hasNim = headers.some(h => h.includes('nim') || h.includes('net interest income'));
            const hasKri = headers.some(h => h.includes('risk status') || h.includes('risk trend') || h.includes('risk outlook'));
            if (hasKri) return 'kri';
            if (hasEve) return 'eve';
            if (hasNim) return 'nim';
            return 'unknown';
        }

        function deriveTitleFromType(detectedType) {
            switch (detectedType) {
                case 'nim':
                    return 'Net Interest Margin Analysis';
                case 'eve':
                    return 'Economic Value of Equity (EVE) Risk Analysis';
                case 'kri':
                    return 'Key Risk Indicators Analysis';
                default:
                    return 'Banking Analytics Summary';
            }
        }

        // Keep all existing modal, chat, and UI functions unchanged...
        // View data modal functions
        currentCsvFile.addEventListener('click', () => showDataModal('csv'));
        currentPdfFile.addEventListener('click', () => showDataModal('pdf'));
        // Prevent preview when clicking upload/remove icons or buttons
        document.querySelectorAll('.file-input-wrapper label, #removePdfBtn, .change-file-btn, .remove-file-btn').forEach(el => {
            el.addEventListener('click', (e) => e.stopPropagation());
        });
        closeModal.addEventListener('click', hideDataModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) hideDataModal();
        });

        function showDataModal(fileType) {
            // Ensure data preview uses the default width
            modalContent.classList.remove('wide');
            if (fileType === 'csv') {
                if (!currentCsvData) {
                    showError('No CSV data loaded');
                    return;
                }

                modalTitle.textContent = `${csvFileName.textContent} - Data Preview`;
                
                if (Array.isArray(currentCsvData) && currentCsvData.length > 0) {
                    modalBody.innerHTML = createTableHTML(currentCsvData);
                } else {
                    modalBody.innerHTML = `<div class="json-view">${JSON.stringify(currentCsvData, null, 2)}</div>`;
                }
            } else if (fileType === 'pdf') {
                if (!currentPdfData) {
                    showError('No PDF loaded');
                    return;
                }

                modalTitle.textContent = `${pdfFileName.textContent} - PDF Preview`;
                
                if (currentPdfData instanceof File || currentPdfData instanceof Blob) {
                    const pdfUrl = URL.createObjectURL(currentPdfData);
                    modalBody.innerHTML = `<iframe src="${pdfUrl}" class="pdf-preview" title="PDF Preview"></iframe>`;
                } else {
                    modalBody.innerHTML = `<div class="pdf-preview">PDF preview not available for this file format</div>`;
                }
            }
            
            modalOverlay.style.display = 'flex';
        }

        function hideDataModal() {
            modalOverlay.style.display = 'none';
            // Reset any width customization
            modalContent.classList.remove('wide');
            // Clean up blob URLs
            const iframe = modalBody.querySelector('iframe');
            if (iframe && iframe.src.startsWith('blob:')) {
                URL.revokeObjectURL(iframe.src);
            }
        }

        function createTableHTML(data) {
            if (!data || data.length === 0) return '<p>No data to display</p>';
            
            const headers = Object.keys(data[0]).filter(key => key !== 'metadata');
            const maxRows = 100;
            const displayData = data.slice(0, maxRows);
            
            let html = '<table class="data-table"><thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            displayData.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header] || ''}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (data.length > maxRows) {
                html += `<p style="margin-top: 10px; color: #666;">Showing first ${maxRows} of ${data.length} rows</p>`;
            }
            
            // Add metadata display if available
            if (data.metadata) {
                html += `<div style="margin-top: 20px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                    <strong>Data Information:</strong><br>
                    Type: ${data.metadata.dataType}<br>
                    Analysis: ${data.metadata.analysisType}<br>
                    Categories: ${data.metadata.categories.join(', ')}<br>
                    Time Horizon: ${data.metadata.timeHorizon}
                </div>`;
            }
            
            return html;
        }

        // Analyze table button
        analyzeTableBtn.addEventListener('click', startAnalysis);

      async function startAnalysis() {
        if (!currentCsvData && !currentPdfData) {
            showError('No data loaded to analyze');
            return;
        }

        analyzeCenter.classList.add('hidden');
        chatInterface.classList.add('active');

        // Use the current prompt editor content for all modes; dataset/context is appended inside sendMessage
        await sendMessage('Analyze', false);
        messageInput.focus();
    }
        // Keep all existing chat functions (addMessage, formatBotResponse, sendMessage, etc.)
        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'bot'}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = isUser ? escapeHtml(content) : formatBotResponse(content);
            
            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatBotResponse(text) {
            let formatted = text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/^#### (.*$)/gm, '<h4>$1</h4>')
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`([^`]+)`/g, '<code>$1</code>');

            formatted = formatted.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');

            const sections = formatted.split(/\n\n+/);
            
            return sections
                .map(section => {
                    section = section.trim();
                    if (!section) return '';
                    
                    if (section.includes('‚Ä¢') || section.match(/^[-*]\s/m)) {
                        return processBulletSection(section);
                    }
                    
                    if (section.startsWith('<h') || section.startsWith('<blockquote>')) {
                        return section;
                    }
                    
                    return `<p>${section.replace(/\n/g, ' ')}</p>`;
                })
                .join('');
        }
        
        function processBulletSection(section) {
            const lines = section.split('\n');
            let result = '';
            let inMainList = false;
            let inSubList = false;
            let currentMainItem = '';
            let subItems = [];
            
            for (let line of lines) {
                line = line.trim();
                
                if (line.match(/^[‚Ä¢*-]\s/)) {
                    if (inSubList && subItems.length > 0) {
                        currentMainItem += '<ul>' + subItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
                        subItems = [];
                        inSubList = false;
                    }
                    
                    if (currentMainItem) {
                        result += `<li>${currentMainItem}</li>`;
                        currentMainItem = '';
                    }
                    
                    if (!inMainList) {
                        result = '<ul>';
                        inMainList = true;
                    }
                    
                    currentMainItem = line.replace(/^[‚Ä¢*-]\s/, '');
                    
                } else if (line.match(/^[‚Ä¢*-]\s/) && currentMainItem && !line.includes('<strong>')) {
                    if (!inSubList) {
                        inSubList = true;
                    }
                    subItems.push(line.replace(/^[‚Ä¢*-]\s/, ''));
                    
                } else if (line && currentMainItem) {
                    currentMainItem += ' ' + line;
                }
            }
            
            if (inSubList && subItems.length > 0) {
                currentMainItem += '<ul>' + subItems.map(item => `<li>${item}</li>`).join('') + '</ul>';
            }
            
            if (currentMainItem) {
                result += `<li>${currentMainItem}</li>`;
            }
            
            if (inMainList) {
                result += '</ul>';
            }
            
            return result;
        }

        function showTyping() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot';
            typingDiv.id = 'typing-indicator';
            
            const typingContent = document.createElement('div');
            typingContent.className = 'typing-indicator';
            typingContent.style.display = 'block';
            typingContent.innerHTML = `
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            
            typingDiv.appendChild(typingContent);
            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideTyping() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            
            if (chatInterface.classList.contains('active')) {
                chatMessages.appendChild(errorDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } else {
                document.querySelector('.file-upload-section').appendChild(errorDiv);
            }
            
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.remove();
                }
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;
            
            document.querySelector('.file-upload-section').appendChild(successDiv);
            
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.remove();
                }
            }, 3000);
        }

        async function sendMessage(prompt = null, showUserMessage = true) {
            const message = prompt || messageInput.value.trim();
            if (!message) return;

            if (showUserMessage) {
                addMessage(message, true);
            }
            
            if (!prompt) {
                messageInput.value = '';
            }
            
            messageInput.disabled = true;
            sendButton.disabled = true;
            showTyping();

            try {
                const config = analysisConfig[activeAnalysis];
                let fullPrompt = message;
                
                // CSV data is primary: ALWAYS include it when available
                if (currentCsvData) {
                    try {
                        const colCount = Array.isArray(currentCsvData) && currentCsvData[0] ? Object.keys(currentCsvData[0]).length : 0;
                        console.log(`[SEND] Attaching CSV dataset (rows=${Array.isArray(currentCsvData) ? currentCsvData.length : 0}, cols=${colCount}) for analysis='${activeAnalysis}'`);
                    } catch (_) {}
                    // Minimal modes: exact prompt from config + dataset only (always include dataset)
                    if (activeAnalysis.includes('-minimal')) {
                        const minimalInstruction = (promptEditor.value && promptEditor.value.trim()) || (analysisConfig[activeAnalysis].minimalPrompt || '');
                        const minimalData = createMinimalDataBlock(currentCsvData);
                        const userIntent = prompt && showUserMessage ? `\n\nUser Question: ${message}\n` : '';

                        // Add strict guardrails to force citing only dataset values
                        const detectedType = detectDataTypeFromColumns(currentCsvData);
                        const title = deriveTitleFromType(detectedType);
                        let strictRules = `\n\nFORMAT & DATA RULES:\n- Begin with the header: ## ${title}.\n- Only cite numbers that appear verbatim in the DATASET.\n- When citing a figure, reference the scenario and column in natural prose (e.g., Net Interest Income at -400bp is 29,098).\n- If a metric is not present as a column, write "Not available".\n- Do not introduce concepts outside the dataset type. For NIM datasets, do NOT mention EVE/economic value. For EVE datasets, do NOT mention NIM/Net Interest unless a column exists.\n- Keep analysis tied to actual rows (e.g., -400bp, Current, +400bp).`;

                        // Add dataset type hint to align the model
                        if (detectedType !== 'unknown') {
                            strictRules += `\nDATASET TYPE DETECTED: ${detectedType.toUpperCase()} (derived from column headers). Align analysis accordingly.`;
                        }

                        fullPrompt = `${minimalInstruction}${strictRules}${userIntent}\n\n${minimalData}`;
                        // OVERRIDE: Respect exact minimal prompt with dataset only (no extra rules)
                        {
                            const _mi = (promptEditor.value && promptEditor.value.trim()) || (analysisConfig[activeAnalysis].minimalPrompt || '');
                            const _md = createMinimalDataBlock(currentCsvData);
                            const _ui = prompt && showUserMessage ? `\n\nUser Question: ${message}\n` : '';
                            fullPrompt = `${_mi}${_ui}\n\n${_md}`;
                        }
                    } else {
                        // Regular modes: add a concise, structured instruction then attach the dataset block
                        const detailedContext = createDetailedDataContext(currentCsvData, activeAnalysis);
                        let instruction = (promptEditor.value && promptEditor.value.trim()) || '';
                        if (!instruction) {
                            if (activeAnalysis.includes('net-interest')) {
                                instruction = `Using only the dataset below (and any uploaded report), write an executive narrative in natural paragraphs. Explain what happens, why, and how across rate shocks (-400 to +400 bps), not just the figures.\n\n- Overall shape: describe earnings sensitivity and any asymmetry (losses in cuts vs gains in hikes).\n- Most adverse: name the scenario and list NIM change (bps) and NII change ($), then one sentence on the driver (e.g., asset yield drop vs liability floors, deposit cost lag).\n- Most favorable: same format, with a one-sentence cause.\n- Higher shocks: note tapering or reversal if visible (e.g., deposit costs accelerate above +200 bps).\n- Drivers: explain asset-side (loans, investments) and liability-side (deposits, borrowings) behavior using patterns in the data (repricing timing, betas, floors, mix shifts).\n\nKeep headings minimal (a single title and a closing ‚ÄúSummary‚Äù). Bold important numbers. If a metric isn‚Äôt present, state "Not available." End with a short bullet list titled ‚ÄúAssumptions to Review‚Äù (3‚Äì5 items) tied to observed patterns.`;
                            } else if (activeAnalysis.includes('rate-risk')) {
                                instruction = `Using only the dataset below (and any uploaded report), write an executive narrative in natural paragraphs. Explain what happens, why, and how across shocks (-400 to +400 bps) based on the data.\n\n- Overall shape: describe interest rate sensitivity and whether outcomes are symmetric or skewed.\n- Most adverse: name the scenario and report the magnitude on the key metric(s) present (EVE %, $, or NIM/NII), then one sentence on the main cause (e.g., duration/convexity effects, liability floors).\n- Most favorable: same format, with a one-sentence cause.\n- Higher shocks: note any tapering or reversals; explain with liability repricing acceleration or asset sensitivity.\n- Drivers: explain asset categories and liability categories that matter most, grounded in repricing timing, duration/sensitivity, deposit betas, floors, and mix.\n\nKeep headings minimal (a single title and a closing ‚ÄúSummary‚Äù). Bold important numbers. If a metric isn‚Äôt present, state "Not available." End with a short bullet list titled ‚ÄúAssumptions to Review‚Äù (3‚Äì5 items) tied to observed patterns.`;
                            } else {
                                instruction = `Provide a concise executive narrative using only the dataset below. Include an Executive Summary, a section on extremes with magnitudes, primary drivers, and assumptions to review. Bold key figures. If metrics are missing, say "Not available."`;
                            }
                        }

                        fullPrompt = `${message}\n\n${instruction}\n\n${detailedContext}`;
                    }
                } else {
                    console.warn(`[SEND] No CSV dataset available to attach for analysis='${activeAnalysis}'. Using PDF/doc context only.`);
                }

                // PDF provides additional institutional context
                // For minimal modes, do not add PDF context
                if (currentPdfData && !activeAnalysis.includes('-minimal')) {
                    fullPrompt += `\n\nADDITIONAL CONTEXT: A PDF report has been uploaded that provides broader institutional context and background for this analysis. Use this as supplementary context to better understand the institution's overall risk profile and strategic position.`;
                }

                // Create FormData for file uploads
                const formData = new FormData();
                formData.append('prompt', fullPrompt);
                const effectiveAnalysisType = includeDocs ? `${activeAnalysis} minimal-docs` : activeAnalysis;
                formData.append('analysisType', effectiveAnalysisType);
                formData.append('useDocuments', includeDocs);
                formData.append('model', selectedModel);

                // Add PDF if available (as supplementary context)
                if (currentPdfData) {
                    formData.append('pdfFile', currentPdfData);
                    formData.append('hasPdf', 'true');
                }

                const response = await fetch('/Chatbot/api/chat', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                hideTyping();

                if (response.ok) {
                    addMessage(data.response);
                } else {
                    showError(data.error || 'Something went wrong');
                }
            } catch (error) {
                hideTyping();
                showError('Network error. Please check your connection.');
                console.error('Error:', error);
            } finally {
                messageInput.disabled = false;
                sendButton.disabled = false;
                if (chatInterface.classList.contains('active')) {
                    messageInput.focus();
                }
            }
        }
        sendButton.addEventListener('click', () => sendMessage());
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    </script>
</body>
</html>
